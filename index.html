<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ã‚³ã‚¹ãƒ¢ãªã½ã‚ŠãŸã‚“ ã‚µãƒã‚¤ãƒãƒ¼ã‚¹ã‚¿ãƒ¼ã‚º ğŸŒŸ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', 'Hiragino Sans', 'Meiryo', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
      color: white;
      overflow: hidden;
    }

    #app {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }

    @media (max-width: 820px) {
      #app {
        align-items: flex-start;
        padding-top: 200px; /* HUDã®é«˜ã•åˆ† + ä½™ç™½ã‚’ã•ã‚‰ã«å¢—ã‚„ã™ */
      }
    }

    @media (max-width: 480px) {
      #app {
        padding-top: 250px; /* ã‚¹ãƒãƒ›ã¯ã•ã‚‰ã«50pxä¸‹ã« */
      }
    }

    #game-container {
      position: relative;
      width: 800px;
      height: 600px;
      max-width: 100vw;
      max-height: 100vh;
      background: #000;
      border: 4px solid #4a90e2;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
    }

    @media (max-width: 820px) {
      #game-container {
        width: 100vw;
        height: calc(100vw * 0.75); /* 4:3ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ */
        max-height: calc(100vh - 220px); /* HUDåˆ†ã®é«˜ã•ã‚’å¼•ã */
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
    }

    @media (max-height: 620px) {
      #game-container {
        width: calc(100vh * 1.333); /* 4:3ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ */
        height: 100vh;
        max-width: 100vw;
        border-radius: 0;
        border-top: none;
        border-bottom: none;
      }
    }

    @media (max-width: 820px) and (max-height: 620px) {
      #game-container {
        width: calc(100vh * 1.333);
        height: 100vh;
      }
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }

    @media (max-width: 820px) {
      #hud {
        position: fixed;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
      }
    }

    @media (max-width: 600px) {
      #hud {
        padding: 10px;
        min-width: 150px;
        position: fixed;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
      }

      .hud-item {
        font-size: 12px !important;
      }

      .hp-bar, .xp-bar {
        height: 16px !important;
      }
    }

    #buffs {
      position: absolute;
      bottom: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    @media (max-width: 600px) {
      #buffs {
        bottom: 5px;
        left: 5px;
      }

      .buff-item {
        padding: 6px 10px !important;
        min-width: 120px !important;
      }

      .buff-icon {
        font-size: 16px !important;
      }

      .buff-name {
        font-size: 10px !important;
      }
    }

    .buff-item {
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 150px;
      border: 2px solid;
    }

    .buff-icon {
      font-size: 20px;
    }

    .buff-info {
      flex: 1;
    }

    .buff-name {
      font-size: 12px;
      font-weight: bold;
    }

    .buff-timer {
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }

    .buff-timer-fill {
      height: 100%;
      background: white;
      transition: width 0.1s linear;
    }

    #pause-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #4a90e2;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      transition: all 0.3s;
    }

    @media (max-width: 600px) {
      #pause-btn {
        width: 40px;
        height: 40px;
        top: 5px;
        right: 5px;
      }

      #pause-btn .pause-icon {
        width: 16px !important;
        height: 20px !important;
      }

      #pause-btn .pause-icon::before,
      #pause-btn .pause-icon::after {
        width: 5px !important;
        height: 20px !important;
      }

      #pause-btn.paused .pause-icon::before {
        border-width: 10px 0 10px 16px !important;
        left: 4px !important;
      }
    }

    #pause-btn:hover {
      background: rgba(74, 144, 226, 0.3);
      transform: scale(1.1);
    }

    #pause-btn .pause-icon {
      width: 20px;
      height: 24px;
      position: relative;
    }

    #pause-btn .pause-icon::before,
    #pause-btn .pause-icon::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 24px;
      background: white;
      border-radius: 2px;
    }

    #pause-btn .pause-icon::before {
      left: 0;
    }

    #pause-btn .pause-icon::after {
      right: 0;
    }

    #pause-btn.paused .pause-icon::before {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 12px 0 12px 20px;
      border-color: transparent transparent transparent white;
      background: transparent;
      left: 5px;
      top: 0;
    }

    #pause-btn.paused .pause-icon::after {
      display: none;
    }

    .hud-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .hp-bar, .xp-bar {
      flex: 1;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ee5a6f);
      transition: width 0.3s ease;
      width: 100%;
    }

    .xp-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #44a08d);
      transition: width 0.3s ease;
      width: 0%;
    }

    .modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: all;
      z-index: 100;
    }

    @media (max-width: 600px) {
      .modal {
        align-items: flex-start;
        padding-top: 0;
      }
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 500px;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
    }

    @media (max-width: 600px) {
      .modal-content {
        max-width: 90vw;
        padding: 15px;
        margin-top: -30px;
      }

      .modal-content h1 {
        font-size: 24px !important;
        margin-bottom: 8px !important;
      }

      .modal-content h2 {
        font-size: 22px !important;
        margin-bottom: 12px !important;
      }

      .modal-content p {
        font-size: 14px !important;
        margin-bottom: 15px !important;
      }

      .upgrade-options {
        gap: 10px !important;
      }

      .upgrade-card {
        padding: 12px !important;
      }

      .upgrade-card h3 {
        font-size: 20px !important;
        margin-bottom: 6px !important;
      }

      .upgrade-card p {
        font-size: 14px !important;
      }

      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }

      .btn-large {
        padding: 12px 32px;
        font-size: 16px;
      }
    }

    @media (max-width: 480px) {
      .modal-content {
        margin-top: -30px !important;
      }
    }

    .modal-content h1 {
      font-size: 36px;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .modal-content h2 {
      font-size: 28px;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .modal-content p {
      font-size: 16px;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      pointer-events: all;
      box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-large {
      padding: 16px 48px;
      font-size: 20px;
    }

    .upgrade-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .upgrade-card {
      background: rgba(255, 255, 255, 0.15);
      padding: 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
      backdrop-filter: blur(10px);
    }

    .upgrade-card:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-4px);
    }

    .upgrade-card h3 {
      font-size: 20px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upgrade-card p {
      font-size: 14px;
      margin: 0;
      opacity: 0.9;
    }

    /* ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    .sound-setting {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 12px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sound-setting label {
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle-switch.active {
      background: #4caf50;
    }

    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(30px);
    }

    .toggle-switch.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(150, 150, 150, 0.3);
    }

    .sound-setting.disabled {
      opacity: 0.5;
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .btn-danger:hover {
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
    }

    .btn-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    .btn-selected {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      
      <div id="ui-overlay">
        <div id="hud">
          <div class="hud-item">
            <span>â¤ï¸ HP:</span>
            <div class="hp-bar">
              <div id="hp-fill" class="hp-fill"></div>
            </div>
            <span id="hp-text">100/100</span>
          </div>
          <div class="hud-item">
            <span>â­ XP:</span>
            <div class="xp-bar">
              <div id="xp-fill" class="xp-fill"></div>
            </div>
            <span id="xp-text">0/10</span>
          </div>
          <div class="hud-item">
            <span>ğŸ¯ ãƒ¬ãƒ™ãƒ«:</span>
            <span id="level-text">1</span>
          </div>
          <div class="hud-item">
            <span>â±ï¸ æ™‚é–“:</span>
            <span id="time-text">0:00</span>
          </div>
        </div>

        <div id="buffs"></div>

        <button id="pause-btn" aria-label="ãƒãƒ¼ã‚º">
          <div class="pause-icon"></div>
        </button>

        <div id="start-modal" class="modal">
          <div class="modal-content">
            <h1>ğŸŒŸ ã‚³ã‚¹ãƒ¢ãªã½ã‚ŠãŸã‚“ ğŸ</h1>
            <h2>ã‚µãƒã‚¤ãƒãƒ¼ã‚¹ã‚¿ãƒ¼ã‚º</h2>
            <p>
              WASDã¾ãŸã¯æ–¹å‘ã‚­ãƒ¼ã§ç§»å‹•ã—ã‚ˆã†ï¼<br>
              ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯ã§ã‚‚ç§»å‹•ã§ãã‚‹ã‚ˆï¼ğŸ–±ï¸<br>
              ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã—ã¦å¼·ããªã‚Šã€<br>
              ãƒœã‚¹ã‚’ãŸãŠãã†!
            </p>
            <div id="music-selection" style="margin-bottom: 20px;">
              <p style="font-size: 18px; margin-bottom: 10px; font-weight: bold;">éŸ³æ¥½è¨­å®š</p>
              <button id="music-on-btn" class="btn" style="margin-right: 10px;">ğŸ”Š éŸ³æ¥½ã‚ã‚Š</button>
              <button id="music-off-btn" class="btn">ğŸ”‡ éŸ³æ¥½ãªã—</button>
            </div>
            <button id="start-btn" class="btn btn-large" style="display: none;">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ ğŸš€</button>
          </div>
        </div>

        <div id="levelup-modal" class="modal hidden">
          <div class="modal-content">
            <h2>ğŸ‰ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼</h2>
            <p>å¼·åŒ–ã‚’é¸ã‚“ã§ãã ã•ã„</p>
            <div id="upgrade-options" class="upgrade-options"></div>
          </div>
        </div>

        <div id="pause-modal" class="modal hidden">
          <div class="modal-content">
            <h2>â¸ï¸ ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼</h2>
            
            <div class="sound-setting">
              <label>
                <span>ğŸµ</span>
                <span>BGM</span>
              </label>
              <div class="toggle-switch active" id="bgm-toggle">
                <div class="toggle-slider"></div>
              </div>
            </div>

            <div class="sound-setting">
              <label>
                <span>ğŸ”Š</span>
                <span>åŠ¹æœéŸ³</span>
              </label>
              <div class="toggle-switch active" id="sfx-toggle">
                <div class="toggle-slider"></div>
              </div>
            </div>

            <div class="btn-group">
              <button class="btn btn-large" id="resume-btn">â–¶ï¸ ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
              <button class="btn btn-large btn-danger" id="quit-btn">ğŸšª ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†</button>
            </div>
          </div>
        </div>

        <div id="gameover-modal" class="modal hidden">
          <div class="modal-content">
            <h2>ğŸ’« ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
            <div id="final-stats" style="margin: 20px 0; font-size: 18px; line-height: 1.8;"></div>
            <button id="restart-btn" class="btn btn-large">ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã«æˆ»ã‚‹</button>
          </div>
        </div>

        <!-- ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div id="gameclear-modal" class="modal hidden">
          <div class="modal-content" style="max-width: 600px;">
            <h2 style="color: #ffd700; font-size: 2.5em; text-shadow: 0 0 20px #ffd700;">ğŸ‰ ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼ ğŸ‰</h2>
            <p style="font-size: 1.3em; margin: 20px 0;">æœ€çµ‚ãƒœã‚¹ã‚’æ’ƒç ´ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼</p>
            <div id="clear-stats" style="margin: 20px 0; font-size: 18px; line-height: 1.8;"></div>
            <div style="margin: 30px 0;">
              <img src="images/kancho.png" alt="ã‚³ã‚¹ãƒ¢ãƒ›ãƒ¼ãƒ«é¤¨é•·" style="max-width: 35%; height: auto; border-radius: 10px; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
            </div>
            <button id="restart-clear-btn" class="btn btn-large" style="background: linear-gradient(135deg, #ffd700, #ffed4e); color: #000; font-weight: bold;">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // æ•µã®ã‚¿ã‚¤ãƒ—å®šç¾©
      const ENEMY_TYPES = {
        BASIC: {
          name: 'åŸºæœ¬æ•µ',
          emoji: 'ğŸ‘¾',
          color: '#ff6b6b',
          secondaryColor: '#e74c3c',
          hp: 22,
          speed: 0.8,
          damage: 5,
          xp: 3,
          spawnWeight: 50,
          minLevel: 1,
        },
        FAST: {
          name: 'é€Ÿã„æ•µ',
          emoji: 'âš¡',
          color: '#feca57',
          secondaryColor: '#f39c12',
          hp: 12,
          speed: 1.5,
          damage: 4,
          xp: 5,
          spawnWeight: 30,
          minLevel: 3,
        },
        SHOOTER: {
          name: 'ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼',
          emoji: 'ğŸŒ€',
          color: '#f39c12',
          secondaryColor: '#e67e22',
          hp: 18,
          speed: 0.7,
          damage: 5,
          xp: 10,
          spawnWeight: 25,
          shootInterval: 2500,
          minLevel: 6,
        },
        TANK: {
          name: 'ã‚¿ãƒ³ã‚¯',
          emoji: 'ğŸ›¡ï¸',
          color: '#9b59b6',
          secondaryColor: '#8e44ad',
          hp: 60,
          speed: 0.35,
          damage: 10,
          xp: 25,
          spawnWeight: 20,
          minLevel: 11,
        },
        CHARGER: {
          name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼',
          emoji: 'ğŸ’¨',
          color: '#e74c3c',
          secondaryColor: '#c0392b',
          hp: 25,
          speed: 0.5,
          damage: 15,
          xp: 20,
          spawnWeight: 15,
          chargeInterval: 3500,
          chargeSpeed: 3.5,
          chargeDuration: 800,
          minLevel: 13,
        },
        DEBUFFER: {
          name: 'ãƒ‡ãƒãƒ•æ•µ',
          emoji: 'ğŸ’€',
          color: '#9b59b6',
          secondaryColor: '#8e44ad',
          hp: 18,
          speed: 0.7,
          damage: 5,
          xp: 18,
          spawnWeight: 15,
          debuffRange: 100,
          minLevel: 15,
        },
        SPLITTER: {
          name: 'ã‚¹ãƒ—ãƒªãƒƒã‚¿ãƒ¼',
          emoji: 'ğŸ”„',
          color: '#2ecc71',
          secondaryColor: '#27ae60',
          hp: 30,
          speed: 0.6,
          damage: 8,
          xp: 22,
          spawnWeight: 10,
          splitCount: 2,
          minLevel: 18,
        },
        MINIBOSS: {
          name: 'ä¸­ãƒœã‚¹',
          emoji: 'ğŸ‘‘',
          color: '#8b00ff',
          secondaryColor: '#6a00cc',
          hp: 250,
          speed: 0.5,
          damage: 15,
          xp: 50,
          spawnWeight: 0,
          shootInterval: 1800,
          minLevel: 1,
        },
        FINALBOSS: {
          name: 'æœ€çµ‚ãƒœã‚¹',
          emoji: 'ğŸ”¥',
          color: '#ff0000',
          secondaryColor: '#cc0000',
          hp: 800,
          speed: 0.6,
          damage: 20,
          xp: 200,
          spawnWeight: 0,
          shootInterval: 1000,
          minLevel: 20,
        }
      };

      function drawPlayer(ctx, player, img, time, isLowSpec = false, isUltraLowSpec = false) {
        ctx.save();
        
        // ç„¡æ•µæ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        const isInvincible = player.invincibleUntil && time < player.invincibleUntil;
        
        if (isInvincible) {
          // è™¹è‰²ã®ã‚ªãƒ¼ãƒ©
          const hue = (time / 10) % 360;
          // ã‚¹ãƒãƒ›ã¯shadowBlurãªã—
          if (!isUltraLowSpec) {
            ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
            ctx.shadowBlur = isLowSpec ? 15 : 30;
          }
          
          if (isLowSpec) {
            // è»½é‡ç‰ˆ: ã‚·ãƒ³ãƒ—ãƒ«ãªè™¹è‰²ã®è¼ª1ã¤
            const radius = player.radius + 15;
            ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.position.x, player.position.y, radius, 0, Math.PI * 2);
            ctx.stroke();
          } else {
            // é€šå¸¸ç‰ˆ: å›è»¢ã™ã‚‹è™¹è‰²ã®è¼ª
            const rotationSpeed = time / 500;
            for (let i = 0; i < 3; i++) {
              const angle = rotationSpeed + (i * Math.PI * 2 / 3);
              const radius = player.radius + 15 + Math.sin(time / 200 + i) * 5;
              
              ctx.strokeStyle = `hsl(${(hue + i * 120) % 360}, 100%, 60%)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(player.position.x, player.position.y, radius, angle, angle + Math.PI);
              ctx.stroke();
            }
            
            // ã‚­ãƒ©ã‚­ãƒ©æ˜Ÿ
            for (let i = 0; i < 6; i++) {
              const starAngle = rotationSpeed * 2 + (i * Math.PI / 3);
              const starDist = player.radius + 20;
              const starX = player.position.x + Math.cos(starAngle) * starDist;
              const starY = player.position.y + Math.sin(starAngle) * starDist;
              const starHue = (hue + i * 60) % 360;
              
              ctx.fillStyle = `hsl(${starHue}, 100%, 80%)`;
              ctx.shadowColor = `hsl(${starHue}, 100%, 70%)`;
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(starX, starY, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
        
        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸç›´å¾Œã¯èµ¤ãé€æ˜ç‚¹æ»…
        const timeSinceDamage = time - player.lastDamageTime;
        if (timeSinceDamage < player.damageCooldown && !isInvincible) {
          const flashInterval = 100;
          if (Math.floor(timeSinceDamage / flashInterval) % 2 === 1) {
            ctx.globalAlpha = 0.5;
          }
          // èµ¤ã„ãƒ†ã‚£ãƒ³ãƒˆ
          ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
          ctx.globalCompositeOperation = 'source-atop';
        }
        
        if (player.shield > 0) {
          const shimmer = Math.sin(time / 200) * 0.3 + 0.7;
          // ã‚¹ãƒãƒ›ã¯shadowBlurãªã—
          if (!isUltraLowSpec) {
            ctx.shadowColor = `rgba(72, 219, 251, ${shimmer})`;
            ctx.shadowBlur = 20;
          }
          ctx.strokeStyle = `rgba(72, 219, 251, ${shimmer})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(player.position.x, player.position.y, player.radius + 10, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        if (img && img.complete) {
          // ã‚¹ãƒãƒ›ã¯ç”»è³ªã‚’ä¸‹ã’ã‚‹
          ctx.imageSmoothingEnabled = !isUltraLowSpec;
          ctx.imageSmoothingQuality = isUltraLowSpec ? 'low' : 'high';
          
          ctx.globalCompositeOperation = 'source-over';
          
          // ç”»åƒã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ä¿æŒ
          const imgAspect = img.width / img.height;
          let drawWidth = player.radius * 2;
          let drawHeight = player.radius * 2;
          
          if (imgAspect > 1) {
            // æ¨ªé•·ã®ç”»åƒ
            drawHeight = drawWidth / imgAspect;
          } else {
            // ç¸¦é•·ã®ç”»åƒ
            drawWidth = drawHeight * imgAspect;
          }
          
          ctx.drawImage(
            img,
            player.position.x - drawWidth / 2,
            player.position.y - drawHeight / 2,
            drawWidth,
            drawHeight
          );
          
          // ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®èµ¤ã„ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆç„¡æ•µæ™‚ä»¥å¤–ï¼‰
          if (timeSinceDamage < player.damageCooldown && !isInvincible) {
            const flashInterval = 100;
            if (Math.floor(timeSinceDamage / flashInterval) % 2 === 1) {
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
              ctx.beginPath();
              ctx.arc(player.position.x, player.position.y, player.radius * 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else {
          ctx.beginPath();
          ctx.arc(player.position.x, player.position.y, player.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ffd700';
          ctx.fill();
          ctx.strokeStyle = '#ffed4e';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawEnemy(ctx, enemy) {
        ctx.save();
        
        const type = enemy.type;
        const time = performance.now();
        
        // ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        if (enemy.damageFlash > 0) {
          ctx.globalAlpha = 0.5 + (enemy.damageFlash / 200);
        }

        // ã‚¿ã‚¤ãƒ—ã”ã¨ã«ç•°ãªã‚‹æç”»
        switch(type.name) {
          case 'åŸºæœ¬æ•µ':
            // ã‚·ãƒ³ãƒ—ãƒ«ãªèµ¤ã„å††
            ctx.beginPath();
            ctx.arc(enemy.position.x, enemy.position.y, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
            
          case 'é€Ÿã„æ•µ':
            // æµç·šå‹ã®é’ã„å½¢ã€å¾Œã‚ã«å°¾
            ctx.translate(enemy.position.x, enemy.position.y);
            const angle = Math.atan2(enemy.velocity.y, enemy.velocity.x);
            ctx.rotate(angle);
            
            // æœ¬ä½“ï¼ˆæµç·šå‹ï¼‰
            ctx.beginPath();
            ctx.ellipse(0, 0, enemy.radius * 1.2, enemy.radius * 0.7, 0, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // å°¾
            const tailLength = enemy.radius * 1.5;
            for (let i = 0; i < 3; i++) {
              const alpha = 0.3 - i * 0.1;
              ctx.strokeStyle = `rgba(52, 152, 219, ${alpha})`;
              ctx.lineWidth = enemy.radius * 0.4 - i * 2;
              ctx.beginPath();
              ctx.moveTo(-enemy.radius, 0);
              ctx.lineTo(-enemy.radius - tailLength + i * 5, 0);
              ctx.stroke();
            }
            break;
            
          case 'ã‚¿ãƒ³ã‚¯':
            // ç´«ã®å…­è§’å½¢
            ctx.translate(enemy.position.x, enemy.position.y);
            ctx.rotate(time / 2000); // ã‚†ã£ãã‚Šå›è»¢
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // è£…ç”²ãƒ©ã‚¤ãƒ³
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              const x = Math.cos(angle) * enemy.radius * 0.5;
              const y = Math.sin(angle) * enemy.radius * 0.5;
              ctx.beginPath();
              ctx.arc(x, y, 2, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
            
          case 'ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼':
            // ã‚ªãƒ¬ãƒ³ã‚¸ã®å††+ç ²èº«+ç…§æº–ãƒãƒ¼ã‚¯
            ctx.translate(enemy.position.x, enemy.position.y);
            const shooterAngle = Math.atan2(
              enemy.targetY - enemy.position.y,
              enemy.targetX - enemy.position.x
            );
            ctx.rotate(shooterAngle);
            
            // æœ¬ä½“
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ç ²èº«
            ctx.fillStyle = type.secondaryColor;
            ctx.fillRect(0, -enemy.radius * 0.3, enemy.radius * 0.8, enemy.radius * 0.6);
            
            // ç…§æº–ãƒãƒ¼ã‚¯
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 1;
            const crosshairSize = 5;
            ctx.beginPath();
            ctx.moveTo(enemy.radius * 0.8 + 5 - crosshairSize, 0);
            ctx.lineTo(enemy.radius * 0.8 + 5 + crosshairSize, 0);
            ctx.moveTo(enemy.radius * 0.8 + 5, -crosshairSize);
            ctx.lineTo(enemy.radius * 0.8 + 5, crosshairSize);
            ctx.stroke();
            break;
            
          case 'ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼':
            // èµ¤ã„ãƒˆã‚²ãƒˆã‚²ï¼ˆçªé€²æ™‚ã«ç™½ãå…‰ã‚‹ï¼‰
            ctx.translate(enemy.position.x, enemy.position.y);
            
            const isCharging = enemy.chargeState === 'charging';
            const isPrepping = enemy.chargeState === 'preparing';
            
            // çªé€²æº–å‚™ä¸­ã¯ç‚¹æ»…
            if (isPrepping) {
              const flash = Math.sin(time / 100) * 0.5 + 0.5;
              ctx.globalAlpha = 0.5 + flash * 0.5;
            }
            
            // ãƒˆã‚²ãƒˆã‚²ã®å††
            const spikes = 8;
            ctx.beginPath();
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (Math.PI / spikes) * i;
              const radius = i % 2 === 0 ? enemy.radius * 1.3 : enemy.radius * 0.7;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // çªé€²ä¸­ã¯ç™½ãå…‰ã‚‹
            if (isCharging) {
              ctx.fillStyle = '#ffffff';
              ctx.shadowColor = '#ffffff';
              ctx.shadowBlur = 20;
            } else {
              ctx.fillStyle = type.color;
            }
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
            
          case 'ãƒ‡ãƒãƒ•æ•µ':
            // ç´«ã®å††+æ³¢ç´‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            ctx.translate(enemy.position.x, enemy.position.y);
            
            // æ³¢ç´‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            const rippleTime = (time / 1000) % 1;
            for (let i = 0; i < 3; i++) {
              const rippleRadius = enemy.radius + (rippleTime + i * 0.33) * type.debuffRange;
              const rippleAlpha = Math.max(0, 0.3 - (rippleTime + i * 0.33) * 0.3);
              
              ctx.strokeStyle = `rgba(155, 89, 182, ${rippleAlpha})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // æœ¬ä½“
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ãƒ‰ã‚¯ãƒ­ãƒãƒ¼ã‚¯é¢¨
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(-enemy.radius * 0.3, -enemy.radius * 0.2, enemy.radius * 0.2, 0, Math.PI * 2);
            ctx.arc(enemy.radius * 0.3, -enemy.radius * 0.2, enemy.radius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'ã‚¹ãƒ—ãƒªãƒƒã‚¿ãƒ¼':
            // ç·‘ã®ç´°èƒå‹+ä¸­å¿ƒã«æ ¸+åˆ†è£‚ç·š
            ctx.translate(enemy.position.x, enemy.position.y);
            
            // ç´°èƒè†œï¼ˆã·ã‚ˆã·ã‚ˆï¼‰
            const wobble = Math.sin(time / 200) * 0.1 + 1;
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
              const angle = (Math.PI * 2 / 16) * i;
              const radiusVar = enemy.radius * wobble * (0.9 + Math.sin(angle * 3 + time / 300) * 0.1);
              const x = Math.cos(angle) * radiusVar;
              const y = Math.sin(angle) * radiusVar;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ä¸­å¿ƒã®æ ¸
            ctx.fillStyle = type.secondaryColor;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // åˆ†è£‚ç·š
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-enemy.radius, 0);
            ctx.lineTo(enemy.radius, 0);
            ctx.moveTo(0, -enemy.radius);
            ctx.lineTo(0, enemy.radius);
            ctx.stroke();
            break;
            
          case 'ä¸­ãƒœã‚¹':
            // å›è»¢ã™ã‚‹äº”è§’å½¢+ã‚ªãƒ¼ãƒ©
            ctx.translate(enemy.position.x, enemy.position.y);
            const bossRotation = time / 1000;
            ctx.rotate(bossRotation);
            
            // ã‚ªãƒ¼ãƒ©
            ctx.shadowColor = type.color;
            ctx.shadowBlur = 20;
            ctx.strokeStyle = type.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius + 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // æœ¬ä½“ï¼ˆäº”è§’å½¢ï¼‰
            ctx.shadowBlur = 0;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ç‹å† ãƒãƒ¼ã‚¯
            ctx.fillStyle = '#ffd700';
            ctx.font = `${enemy.radius}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ‘‘', 0, 0);
            break;
            
          case 'æœ€çµ‚ãƒœã‚¹':
            // å·¨å¤§ã§å¨åœ§æ„Ÿã®ã‚ã‚‹æœ€çµ‚ãƒœã‚¹
            ctx.translate(enemy.position.x, enemy.position.y);
            const finalBossRotation = time / 800;
            ctx.rotate(finalBossRotation);
            
            // å¤šé‡ã‚ªãƒ¼ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            for (let i = 0; i < 3; i++) {
              const auraRadius = enemy.radius + 12 + i * 8;
              const auraAlpha = 0.3 - i * 0.1;
              ctx.strokeStyle = `rgba(255, 0, 0, ${auraAlpha})`;
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // ç‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;
            
            // æœ¬ä½“ï¼ˆå…«è§’å½¢ï¼‰
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 / 8) * i - Math.PI / 2;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.radius);
            gradient.addColorStop(0, '#ff6600');
            gradient.addColorStop(0.5, '#ff0000');
            gradient.addColorStop(1, '#cc0000');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // ç‚ãƒãƒ¼ã‚¯
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffff00';
            ctx.font = `${enemy.radius * 1.2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ”¥', 0, 0);
            
            // å‘¨å›²ã«å›è»¢ã™ã‚‹ç‚
            for (let i = 0; i < 6; i++) {
              const flameAngle = finalBossRotation * 2 + (i * Math.PI / 3);
              const flameDist = enemy.radius + 15;
              const flameX = Math.cos(flameAngle) * flameDist;
              const flameY = Math.sin(flameAngle) * flameDist;
              
              ctx.font = '16px Arial';
              ctx.fillText('ğŸ”¥', flameX, flameY);
            }
            break;
        }

        ctx.restore();
        
        // HPãƒãƒ¼ï¼ˆã‚¿ãƒ³ã‚¯ã€ä¸­ãƒœã‚¹ã€ã‚¹ãƒ—ãƒªãƒƒã‚¿ãƒ¼ã€æœ€çµ‚ãƒœã‚¹ã®ã¿ï¼‰
        if (type.name === 'ã‚¿ãƒ³ã‚¯' || type.name === 'ä¸­ãƒœã‚¹' || type.name === 'ã‚¹ãƒ—ãƒªãƒƒã‚¿ãƒ¼' || type.name === 'æœ€çµ‚ãƒœã‚¹') {
          ctx.save();
          const barWidth = enemy.radius * 2;
          const barHeight = type.name === 'æœ€çµ‚ãƒœã‚¹' ? 6 : 4;
          const barX = enemy.position.x - enemy.radius;
          const barY = enemy.position.y - enemy.radius - (type.name === 'æœ€çµ‚ãƒœã‚¹' ? 15 : 10);
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          const hpPercent = enemy.hp / enemy.maxHp;
          ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
          ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
          ctx.restore();
        }
      }

      function drawItem(ctx, item) {
        ctx.save();
        
        const pulse = Math.sin(performance.now() / 200) * 0.2 + 1;
        const radius = item.radius * pulse;
        
        ctx.shadowColor = item.color;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(item.position.x, item.position.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = item.color;
        ctx.fill();
        
        ctx.font = `${radius * 1.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.emoji, item.position.x, item.position.y);
        
        ctx.restore();
      }

      function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å‡ºç¾å¯èƒ½ãªæ•µã‚¿ã‚¤ãƒ—ã‚’é¸æŠï¼ˆé‡ã¿ä»˜ãï¼‰
      function getRandomEnemyType(playerLevel) {
        const availableTypes = Object.values(ENEMY_TYPES).filter(t => 
          t.spawnWeight > 0 && t.minLevel <= playerLevel
        );
        
        if (availableTypes.length === 0) {
          return ENEMY_TYPES.BASIC;
        }
        
        const totalWeight = availableTypes.reduce((sum, t) => sum + t.spawnWeight, 0);
        let random = Math.random() * totalWeight;
        
        for (const type of availableTypes) {
          random -= type.spawnWeight;
          if (random <= 0) {
            return type;
          }
        }
        
        return availableTypes[0];
      }

      // Web Audio API ã‚’ä½¿ã£ãŸè»½é‡ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
      class AudioManager {
        constructor() {
          this.audioContext = null;
          this.bgmBuffers = {}; // ãƒ‡ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ãƒãƒƒãƒ•ã‚¡ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
          this.sfxBuffers = {}; // åŠ¹æœéŸ³ãƒãƒƒãƒ•ã‚¡ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
          this.currentBGM = null; // ç¾åœ¨å†ç”Ÿä¸­ã®BGMã‚½ãƒ¼ã‚¹
          this.bgmGainNode = null; // BGMéŸ³é‡ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
          this.sfxGainNode = null; // åŠ¹æœéŸ³éŸ³é‡ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
          this.isInitialized = false;
          this.isPreloading = false;
          this.preloadProgress = 0;
        }

        // AudioContextã‚’åˆæœŸåŒ–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«å‘¼ã¶ï¼‰
        async init() {
          if (this.isInitialized) return;

          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // ã‚²ã‚¤ãƒ³ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
            this.bgmGainNode = this.audioContext.createGain();
            this.bgmGainNode.connect(this.audioContext.destination);
            
            this.sfxGainNode = this.audioContext.createGain();
            this.sfxGainNode.connect(this.audioContext.destination);
            
            // iOS/Androidå¯¾å¿œ: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’resumeã™ã‚‹
            if (this.audioContext.state === 'suspended') {
              await this.audioContext.resume();
            }
            
            this.isInitialized = true;
            console.log('ğŸµ AudioContext initialized');
          } catch (error) {
            console.error('AudioContext initialization failed:', error);
          }
        }

        // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éåŒæœŸãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
        async preloadAudio(name, url, type = 'bgm') {
          if (!this.isInitialized) {
            console.warn('AudioContext not initialized');
            return;
          }

          try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            
            if (type === 'bgm') {
              this.bgmBuffers[name] = audioBuffer;
            } else {
              this.sfxBuffers[name] = audioBuffer;
            }
            
            console.log(`âœ… Loaded: ${name}`);
          } catch (error) {
            console.error(`Failed to load ${name}:`, error);
          }
        }

        // è¤‡æ•°ã®éŸ³å£°ã‚’ã¾ã¨ã‚ã¦ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
        async preloadAll(bgmList, sfxList) {
          if (!this.isInitialized) {
            await this.init();
          }

          this.isPreloading = true;
          const totalFiles = bgmList.length + sfxList.length;
          let loadedFiles = 0;

          const updateProgress = () => {
            loadedFiles++;
            this.preloadProgress = (loadedFiles / totalFiles) * 100;
          };

          const bgmPromises = bgmList.map(item => 
            this.preloadAudio(item.name, item.url, 'bgm').then(updateProgress)
          );
          
          const sfxPromises = sfxList.map(item => 
            this.preloadAudio(item.name, item.url, 'sfx').then(updateProgress)
          );

          await Promise.all([...bgmPromises, ...sfxPromises]);
          
          this.isPreloading = false;
          console.log('ğŸ‰ All audio files loaded!');
        }

        // BGMã‚’å†ç”Ÿï¼ˆãƒ«ãƒ¼ãƒ—å¯¾å¿œï¼‰
        playBGM(name, volume = 0.5) {
          if (!this.isInitialized || !this.bgmBuffers[name]) {
            console.warn(`BGM ${name} not loaded`);
            return;
          }

          // ç¾åœ¨ã®BGMã‚’åœæ­¢
          this.stopBGM();

          try {
            // æ–°ã—ã„ã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
            const source = this.audioContext.createBufferSource();
            source.buffer = this.bgmBuffers[name];
            source.loop = true; // ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
            source.connect(this.bgmGainNode);
            
            // éŸ³é‡è¨­å®š
            this.bgmGainNode.gain.value = volume;
            
            // å†ç”Ÿé–‹å§‹
            source.start(0);
            
            this.currentBGM = source;
            console.log(`ğŸµ Playing BGM: ${name}`);
          } catch (error) {
            console.error(`Failed to play BGM ${name}:`, error);
          }
        }

        // BGMã‚’åœæ­¢
        stopBGM() {
          if (this.currentBGM) {
            try {
              this.currentBGM.stop();
              this.currentBGM.disconnect();
            } catch (error) {
              // ã™ã§ã«åœæ­¢ã—ã¦ã„ã‚‹å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–
            }
            this.currentBGM = null;
          }
        }

        // åŠ¹æœéŸ³ã‚’å†ç”Ÿï¼ˆåŒæ™‚å†ç”Ÿå¯èƒ½ï¼‰
        playSFX(name, volume = 0.5) {
          if (!this.isInitialized || !this.sfxBuffers[name]) {
            console.warn(`SFX ${name} not loaded`);
            return;
          }

          try {
            const source = this.audioContext.createBufferSource();
            source.buffer = this.sfxBuffers[name];
            source.connect(this.sfxGainNode);
            
            // éŸ³é‡è¨­å®š
            this.sfxGainNode.gain.value = volume;
            
            // å†ç”Ÿé–‹å§‹ï¼ˆãƒ«ãƒ¼ãƒ—ãªã—ï¼‰
            source.start(0);
            
            // å†ç”Ÿçµ‚äº†å¾Œã«è‡ªå‹•çš„ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            source.onended = () => {
              source.disconnect();
            };
          } catch (error) {
            console.error(`Failed to play SFX ${name}:`, error);
          }
        }

        // BGMéŸ³é‡ã‚’å¤‰æ›´
        setBGMVolume(volume) {
          if (this.bgmGainNode) {
            this.bgmGainNode.gain.value = volume;
          }
        }

        // åŠ¹æœéŸ³éŸ³é‡ã‚’å¤‰æ›´
        setSFXVolume(volume) {
          if (this.sfxGainNode) {
            this.sfxGainNode.gain.value = volume;
          }
        }

        // AudioContextã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚’ç¢ºèª
        getState() {
          return this.audioContext ? this.audioContext.state : 'not initialized';
        }
      }

      class Game {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.isRunning = false;
          this.isPaused = false;
          this.isGameOver = false;
          this.lastTime = 0;
          this.gameTime = 0;
          
          // ãƒ‡ãƒã‚¤ã‚¹åˆ¤å®š(ã‚¹ãƒãƒ›ã¯è¶…è»½é‡ç‰ˆã€ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯è»½é‡ç‰ˆ)
          this.isMobile = window.innerWidth <= 600;
          this.isTablet = window.innerWidth > 600 && window.innerWidth <= 820;
          this.isUltraLowSpec = this.isMobile; // ã‚¹ãƒãƒ›å°‚ç”¨è¶…è»½é‡ãƒ¢ãƒ¼ãƒ‰
          this.isLowSpec = this.isMobile || this.isTablet; // å¾“æ¥ã®è»½é‡ãƒ¢ãƒ¼ãƒ‰

          this.playerImage = new Image();
          this.playerImage.src = 'images/cosmo-napolitan.png';
          this.playerImageLoaded = false;
          
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”»åƒã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
          this.playerImage.onload = () => {
            this.playerImageLoaded = true;
            console.log('âœ… Player image loaded');
          };
          
          this.playerImage.onerror = () => {
            console.error('âŒ Failed to load player image');
            this.playerImageLoaded = true; // ã‚¨ãƒ©ãƒ¼ã§ã‚‚é€²ã‚ã‚‹
          };

          this.player = {
            position: { x: canvas.width / 2, y: canvas.height / 2 },
            velocity: { x: 0, y: 0 },
            radius: this.isUltraLowSpec ? 28 : (this.isLowSpec ? 22 : 16), // ã‚¹ãƒãƒ›1.75å€ã€ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ1.375å€
            speed: 150,
            hp: 100,
            maxHp: 100,
            xp: 0,
            xpToNextLevel: 10,
            level: 1,
            damage: 15,
            attackSpeed: 1.0,
            projectileSpeed: 300,
            projectileSize: 1.0,
            piercing: 0,
            range: 250,
            shield: 0,
            lastDamageTime: 0, // æœ€å¾Œã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸæ™‚åˆ»
            damageCooldown: 500, // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼ˆãƒŸãƒªç§’ï¼‰
            projectileCount: 1, // åŒæ™‚ã«ç™ºå°„ã™ã‚‹å¼¾æ•°
            invincibleUntil: 0, // ç„¡æ•µæ™‚é–“ã®çµ‚äº†æ™‚åˆ»
          };

          this.keys = {};
          this.mouseTarget = null; // ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ç›®æ¨™åœ°ç‚¹
          this.enemies = [];
          this.projectiles = [];
          this.enemyProjectiles = [];
          this.xpOrbs = [];
          this.items = [];

          this.lastShootTime = 0;
          this.lastEnemySpawnTime = 0;
          // ã‚¹ãƒãƒ›ã¯æ•µã®ã‚¹ãƒãƒ¼ãƒ³é–“éš”ã‚’2å€ã«
          this.enemySpawnInterval = this.isUltraLowSpec ? 3000 : 1500;
          this.lastBossLevel = 0; // æœ€å¾Œã«ãƒœã‚¹ã‚’å‡ºç¾ã•ã›ãŸãƒ¬ãƒ™ãƒ«
          this.finalBossSpawned = false; // æœ€çµ‚ãƒœã‚¹ãŒå‡ºç¾ã—ãŸã‹

          this.stats = {
            enemiesKilled: 0,
            damageDealt: 0,
            timeAlive: 0,
            level: 1,
          };

          // æ–°ã—ã„ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ç”¨
          this.audioManager = new AudioManager();
          this.currentBGMName = null;
          
          // ã‚µã‚¦ãƒ³ãƒ‰è¨­å®š
          // ã‚¹ãƒãƒ›: BGM OFFã€åŠ¹æœéŸ³ ON
          // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆãƒ»PC: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆOFF(ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠ)
          this.bgmEnabled = !this.isLowSpec; // ã‚¹ãƒãƒ›ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã§ã¯BGM OFF
          this.sfxEnabled = this.isUltraLowSpec ? true : !this.isLowSpec; // ã‚¹ãƒãƒ›ã¯åŠ¹æœéŸ³ONã€ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã¯OFF
          
          // éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆ
          this.bgmList = this.isUltraLowSpec ? [] : [
            { name: 'title', url: 'audio/title_bgm.mp3' },
            { name: 'normal', url: 'audio/normal_bgm.mp3' },
            // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆï¼ˆisLowSpecï¼‰ä»¥å¤–ã®ã¿è¿½åŠ ã®BGMã‚’èª­ã¿è¾¼ã‚€
            ...(this.isLowSpec && !this.isUltraLowSpec ? [] : [
              { name: 'miniboss', url: 'audio/miniboss_bgm.mp3' },
              { name: 'finalboss', url: 'audio/finalboss_bgm.mp3' },
              { name: 'clear', url: 'audio/clear_bgm.mp3' },
              { name: 'gameover', url: 'audio/gameover_bgm.mp3' }
            ])
          ];
          
          // åŠ¹æœéŸ³ã¯æœ€å°é™ã®ã¿å…ˆèª­ã¿
          this.sfxList = [
            { name: 'playerHit', url: 'audio/player_damage.mp3' },
            { name: 'gemGet', url: 'audio/gem_get.mp3' },
            // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆï¼ˆisLowSpecï¼‰ä»¥å¤–ã®ã¿è¿½åŠ ã®åŠ¹æœéŸ³ã‚’èª­ã¿è¾¼ã‚€
            ...(this.isLowSpec && !this.isUltraLowSpec ? [] : [
              { name: 'enemyHit', url: 'audio/enemy_hit.mp3' },
              { name: 'enemyDeath', url: 'audio/enemy_death.mp3' },
              { name: 'bossDeath', url: 'audio/boss_death.mp3' },
              { name: 'itemGet', url: 'audio/item_get.mp3' }
            ])
          ];


          this.activeEffects = {
            speedBoost: 0,
            powerUp: 0,
            timeSlow: 0,
            invincible: 0,
            magnet: 0,
          };

          this.itemNotification = null;
          this.itemNotificationTime = 0;

          this.setupUI();
          this.setupEventListeners();
        }

        setupUI() {
          this.hpFill = document.getElementById('hp-fill');
          this.hpText = document.getElementById('hp-text');
          this.xpFill = document.getElementById('xp-fill');
          this.xpText = document.getElementById('xp-text');
          this.levelText = document.getElementById('level-text');
          this.timeText = document.getElementById('time-text');
          this.buffsFill = document.getElementById('buffs');
          
          this.startModal = document.getElementById('start-modal');
          this.levelupModal = document.getElementById('levelup-modal');
          this.pauseModal = document.getElementById('pause-modal');
          this.gameoverModal = document.getElementById('gameover-modal');
          this.gameclearModal = document.getElementById('gameclear-modal');
          this.upgradeOptions = document.getElementById('upgrade-options');
          
          // ã‚¹ãƒãƒ›ã®å ´åˆã€éŸ³æ¥½é¸æŠãƒœã‚¿ãƒ³ã‚’éæ´»æ€§ã«ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã¿è¡¨ç¤º
          if (this.isUltraLowSpec) {
            const musicSelection = document.getElementById('music-selection');
            const musicOnBtn = document.getElementById('music-on-btn');
            const musicOffBtn = document.getElementById('music-off-btn');
            const startBtn = document.getElementById('start-btn');
            
            // éŸ³æ¥½é¸æŠãƒœã‚¿ãƒ³ã‚’éæ´»æ€§åŒ–ï¼ˆéè¡¨ç¤ºã«ã›ãšã€ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆï¼‰
            if (musicOnBtn) {
              musicOnBtn.disabled = true;
              musicOnBtn.style.opacity = '0.5';
              musicOnBtn.style.cursor = 'not-allowed';
            }
            if (musicOffBtn) {
              musicOffBtn.disabled = true;
              musicOffBtn.style.opacity = '0.5';
              musicOffBtn.style.cursor = 'not-allowed';
            }
            
            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (startBtn) startBtn.style.display = 'inline-block';
            
            // BGMãƒ»åŠ¹æœéŸ³ãƒˆã‚°ãƒ«ã‚’éæ´»æ€§åŒ–
            const bgmToggle = document.getElementById('bgm-toggle');
            const sfxToggle = document.getElementById('sfx-toggle');
            const soundSettings = document.querySelectorAll('.sound-setting');
            
            if (bgmToggle) {
              bgmToggle.classList.add('disabled');
              bgmToggle.classList.remove('active');
            }
            if (sfxToggle) {
              sfxToggle.classList.add('disabled');
              sfxToggle.classList.remove('active');
            }
            soundSettings.forEach(setting => {
              setting.classList.add('disabled');
            });
          }
          this.buffsContainer = document.getElementById('buffs');

          this.pauseBtn = document.getElementById('pause-btn');
        }

        setupEventListeners() {
          const musicOnBtn = document.getElementById('music-on-btn');
          const musicOffBtn = document.getElementById('music-off-btn');
          const startBtn = document.getElementById('start-btn');

          // éŸ³æ¥½ã‚ã‚Šãƒœã‚¿ãƒ³
          musicOnBtn.addEventListener('click', async () => {
            this.bgmEnabled = true;
            this.sfxEnabled = true; // åŠ¹æœéŸ³ã‚‚ONã«
            document.getElementById('bgm-toggle').classList.add('active');
            document.getElementById('sfx-toggle').classList.add('active'); // åŠ¹æœéŸ³ãƒˆã‚°ãƒ«ã‚‚ONã«
            
            // ãƒœã‚¿ãƒ³ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            musicOnBtn.classList.add('btn-selected');
            musicOffBtn.classList.remove('btn-selected');
            
            // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–ï¼ˆãƒ­ãƒ¼ãƒ‰ä¸­ï¼‰
            musicOnBtn.disabled = true;
            musicOnBtn.textContent = 'ğŸ”Š èª­ã¿è¾¼ã¿ä¸­...';
            
            try {
              // AudioManagerã‚’åˆæœŸåŒ–ã—ã¦ãƒ—ãƒªãƒ­ãƒ¼ãƒ‰
              console.log('ğŸµ Initializing AudioManager...');
              await this.audioManager.init();
              console.log('âœ… AudioManager initialized');
              
              console.log('ğŸ“¥ Preloading audio files...');
              await this.audioManager.preloadAll(this.bgmList, this.sfxList);
              console.log('âœ… All audio files loaded');
              
              // ã‚¿ã‚¤ãƒˆãƒ«BGMã‚’å†ç”Ÿ
              console.log('â–¶ï¸ Playing title BGM...');
              this.playBGM('title');
              
              // ãƒœã‚¿ãƒ³ã‚’å…ƒã«æˆ»ã™
              musicOnBtn.disabled = false;
              musicOnBtn.textContent = 'ğŸ”Š éŸ³æ¥½ã‚ã‚Š';
              
              // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
              startBtn.style.display = 'inline-block';
            } catch (error) {
              console.error('âŒ Audio initialization failed:', error);
              alert('éŸ³æ¥½ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚éŸ³æ¥½ãªã—ã§ç¶šè¡Œã—ã¾ã™ã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
              
              // ã‚¨ãƒ©ãƒ¼æ™‚ã®å‡¦ç†
              this.bgmEnabled = false;
              musicOnBtn.disabled = false;
              musicOnBtn.textContent = 'ğŸ”Š éŸ³æ¥½ã‚ã‚Š';
              startBtn.style.display = 'inline-block';
            }
          });

          // éŸ³æ¥½ãªã—ãƒœã‚¿ãƒ³
          musicOffBtn.addEventListener('click', async () => {
            this.bgmEnabled = false;
            this.sfxEnabled = false; // åŠ¹æœéŸ³ã‚‚OFFã«
            document.getElementById('bgm-toggle').classList.remove('active');
            document.getElementById('sfx-toggle').classList.remove('active'); // åŠ¹æœéŸ³ãƒˆã‚°ãƒ«ã‚‚OFFã«
            
            // ãƒœã‚¿ãƒ³ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            musicOffBtn.classList.add('btn-selected');
            musicOnBtn.classList.remove('btn-selected');
            
            // éŸ³æ¥½ãªã—ã®å ´åˆã‚‚ã€åŠ¹æœéŸ³ã®ãŸã‚ã«AudioManagerã‚’åˆæœŸåŒ–
            if (!this.audioManager.isInitialized) {
              musicOffBtn.disabled = true;
              musicOffBtn.textContent = 'ğŸ”‡ èª­ã¿è¾¼ã¿ä¸­...';
              
              await this.audioManager.init();
              await this.audioManager.preloadAll([], this.sfxList); // åŠ¹æœéŸ³ã®ã¿ãƒ­ãƒ¼ãƒ‰
              
              musicOffBtn.disabled = false;
              musicOffBtn.textContent = 'ğŸ”‡ éŸ³æ¥½ãªã—';
            }
            
            // BGMã‚’åœæ­¢
            this.stopBGM();
            
            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            startBtn.style.display = 'inline-block';
          });

          // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
          startBtn.addEventListener('click', async () => {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”»åƒã®èª­ã¿è¾¼ã¿ã‚’å¾…ã¤
            if (!this.playerImageLoaded) {
              console.log('â³ Waiting for player image to load...');
              await new Promise(resolve => {
                if (this.playerImage.complete) {
                  resolve();
                } else {
                  this.playerImage.onload = () => {
                    this.playerImageLoaded = true;
                    resolve();
                  };
                  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ3ç§’ï¼‰
                  setTimeout(resolve, 3000);
                }
              });
            }
            
            this.stopBGM(); // ã‚¿ã‚¤ãƒˆãƒ«BGMã‚’åœæ­¢
            this.startModal.classList.add('hidden');
            this.start();
          });

          document.getElementById('restart-btn').addEventListener('click', () => {
            window.location.reload();
          });

          document.getElementById('restart-clear-btn').addEventListener('click', () => {
            window.location.reload();
          });

          document.getElementById('resume-btn').addEventListener('click', () => {
            this.togglePause();
          });

          this.pauseBtn.addEventListener('click', () => {
            this.togglePause();
          });

          document.addEventListener('keydown', (e) => {
            this.keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'p' && this.isRunning && !this.isGameOver) {
              this.togglePause();
            }
          });

          document.addEventListener('keyup', (e) => {
            this.keys[e.key.toLowerCase()] = false;
          });

          // ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯ã§ç§»å‹•
          this.canvas.addEventListener('mousedown', (e) => {
            if (this.isPaused || this.isGameOver) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            this.mouseTarget = {
              x: (e.clientX - rect.left) * scaleX,
              y: (e.clientY - rect.top) * scaleY
            };
          });

          // ãƒã‚¦ã‚¹ç§»å‹•ä¸­ã‚‚ç›®æ¨™åœ°ç‚¹ã‚’æ›´æ–°ï¼ˆãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œï¼‰
          this.canvas.addEventListener('mousemove', (e) => {
            if (this.isPaused || this.isGameOver) return;
            if (e.buttons !== 1) return; // å·¦ã‚¯ãƒªãƒƒã‚¯ä¸­ã®ã¿
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            this.mouseTarget = {
              x: (e.clientX - rect.left) * scaleX,
              y: (e.clientY - rect.top) * scaleY
            };
          });

          // ãƒã‚¦ã‚¹ã‚’é›¢ã—ãŸã‚‰ç§»å‹•åœæ­¢
          this.canvas.addEventListener('mouseup', () => {
            this.mouseTarget = null;
          });

          // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œ
          this.canvas.addEventListener('touchstart', (e) => {
            if (this.isPaused || this.isGameOver) return;
            e.preventDefault();
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            
            this.mouseTarget = {
              x: (touch.clientX - rect.left) * scaleX,
              y: (touch.clientY - rect.top) * scaleY
            };
          });

          this.canvas.addEventListener('touchmove', (e) => {
            if (this.isPaused || this.isGameOver) return;
            e.preventDefault();
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            
            this.mouseTarget = {
              x: (touch.clientX - rect.left) * scaleX,
              y: (touch.clientY - rect.top) * scaleY
            };
          });

          this.canvas.addEventListener('touchend', () => {
            this.mouseTarget = null;
          });


          // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒœã‚¿ãƒ³
          document.getElementById('quit-btn').addEventListener('click', () => {
            if (confirm('æœ¬å½“ã«ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿ')) {
              this.quitGame();
            }
          });

          // BGMãƒˆã‚°ãƒ«
          document.getElementById('bgm-toggle').addEventListener('click', (e) => {
            // ã‚¹ãƒãƒ›ã®å ´åˆã¯ç„¡åŠ¹
            if (this.isUltraLowSpec) return;
            
            this.bgmEnabled = !this.bgmEnabled;
            e.currentTarget.classList.toggle('active', this.bgmEnabled);
            
            if (this.bgmEnabled && !this.isPaused) {
              this.playBGM(this.currentBGMName || 'normal');
            } else {
              this.stopBGM();
            }
          });

          // åŠ¹æœéŸ³ãƒˆã‚°ãƒ«
          document.getElementById('sfx-toggle').addEventListener('click', (e) => {
            // ã‚¹ãƒãƒ›ã®å ´åˆã¯ç„¡åŠ¹
            if (this.isUltraLowSpec) return;
            
            this.sfxEnabled = !this.sfxEnabled;
            e.currentTarget.classList.toggle('active', this.sfxEnabled);
          });
        }

        start() {
          this.isRunning = true;
          this.lastTime = performance.now();
          this.gameLoop(this.lastTime);
          
          // é€šå¸¸æˆ¦é—˜BGMã‚’å†ç”Ÿ
          this.playBGM('normal');
        }

        playBGM(type) {
          // ã‚µã‚¦ãƒ³ãƒ‰è¨­å®šãŒOFFã®å ´åˆã¯å†ç”Ÿã—ãªã„
          if (!this.bgmEnabled) return;
          
          // ç¾åœ¨ã®ã‚¿ã‚¤ãƒ—ã‚’ä¿å­˜
          this.currentBGMName = type;
          
          // éŸ³é‡ãƒãƒƒãƒ—
          const volumeMap = {
            'title': 0.5,
            'normal': 0.5,
            'miniboss': 0.6,
            'finalboss': 0.7,
            'clear': 0.6,
            'gameover': 0.5
          };
          
          // AudioManagerã§å†ç”Ÿ
          const volume = volumeMap[type] || 0.5;
          this.audioManager.playBGM(type, volume);
        }

        stopBGM() {
          this.audioManager.stopBGM();
        }

        playSFX(type) {
          // åŠ¹æœéŸ³è¨­å®šãŒOFFã®å ´åˆã¯å†ç”Ÿã—ãªã„
          if (!this.sfxEnabled) return;
          
          // éŸ³é‡ãƒãƒƒãƒ—
          const volumeMap = {
            'playerHit': 0.6,
            'enemyHit': 0.15,
            'enemyDeath': 0.5,
            'bossDeath': 0.7,
            'gemGet': 0.5,
            'itemGet': 0.6
          };
          
          // AudioManagerã§å†ç”Ÿ
          const volume = volumeMap[type] || 0.5;
          this.audioManager.playSFX(type, volume);
        }

        togglePause() {
          if (this.isGameOver) return;
          
          this.isPaused = !this.isPaused;
          this.pauseModal.classList.toggle('hidden');
          this.pauseBtn.classList.toggle('paused');
          
          if (this.isPaused) {
            // ãƒãƒ¼ã‚ºæ™‚ã¯BGMã‚’åœæ­¢
            if (this.bgmEnabled) {
              this.stopBGM();
            }
          } else {
            // å†é–‹æ™‚ã¯BGMã‚’å†ç”Ÿ
            this.lastTime = performance.now();
            if (this.bgmEnabled) {
              this.playBGM(this.currentBGMName || 'normal');
            }
            this.gameLoop(this.lastTime);
          }
        }

        quitGame() {
          this.isGameOver = true;
          this.stopBGM();
          this.pauseModal.classList.add('hidden');
          
          // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã«æˆ»ã‚‹
          window.location.reload();
        }

        gameLoop(currentTime) {
          if (!this.isRunning || this.isPaused) return;

          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;

          this.update(deltaTime, currentTime);
          this.render();

          if (!this.isGameOver) {
            requestAnimationFrame((time) => this.gameLoop(time));
          }
        }

        update(deltaTime, currentTime) {
          this.gameTime += deltaTime * 1000;
          this.timeText.textContent = formatTime(this.gameTime);

          const timeSlowActive = this.activeEffects.timeSlow > currentTime;
          const effectiveDelta = timeSlowActive ? deltaTime * 0.5 : deltaTime;

          this.updatePlayer(deltaTime);
          this.updateEnemies(effectiveDelta, currentTime);
          this.updateProjectiles(deltaTime);
          this.updateEnemyProjectiles(deltaTime);
          this.updateXPOrbs(deltaTime);
          this.updateItems(deltaTime);
          this.updateEffects(currentTime);
          this.updateBuffsUI();

          this.shoot(currentTime);
          this.spawnEnemies(currentTime);

          this.checkCollisions();
        }

        updatePlayer(deltaTime) {
          let dx = 0;
          let dy = 0;

          // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
          let keyboardInput = false;
          if (this.keys['w'] || this.keys['arrowup']) { dy -= 1; keyboardInput = true; }
          if (this.keys['s'] || this.keys['arrowdown']) { dy += 1; keyboardInput = true; }
          if (this.keys['a'] || this.keys['arrowleft']) { dx -= 1; keyboardInput = true; }
          if (this.keys['d'] || this.keys['arrowright']) { dx += 1; keyboardInput = true; }

          // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ãŒã‚ã£ãŸã‚‰ãƒã‚¦ã‚¹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢
          if (keyboardInput) {
            this.mouseTarget = null;
          }

          // ãƒã‚¦ã‚¹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒã‚ã‚‹å ´åˆ
          if (!keyboardInput && this.mouseTarget) {
            const targetDx = this.mouseTarget.x - this.player.position.x;
            const targetDy = this.mouseTarget.y - this.player.position.y;
            const distance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);

            // ç›®æ¨™åœ°ç‚¹ã«ååˆ†è¿‘ã¥ã„ãŸã‚‰åœæ­¢
            if (distance < 5) {
              this.mouseTarget = null;
            } else {
              dx = targetDx / distance;
              dy = targetDy / distance;
            }
          }

          if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx * dx + dy * dy);
            dx /= length;
            dy /= length;

            let speedMultiplier = this.activeEffects.speedBoost > performance.now() ? 1.5 : 1.0;
            
            // ãƒ‡ãƒãƒ•æ•µã®ç¯„å›²å†…ã«ã„ã‚‹å ´åˆã¯é€Ÿåº¦ã‚’ä¸‹ã’ã‚‹
            if (this.debuffedByEnemy) {
              speedMultiplier *= 0.5;
            }
            
            const speed = this.player.speed * speedMultiplier;

            this.player.position.x += dx * speed * deltaTime;
            this.player.position.y += dy * speed * deltaTime;

            this.player.position.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.position.x));
            this.player.position.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.position.y));
          }
        }

        updateEnemies(deltaTime, currentTime) {
          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            // ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼ã®çªé€²å‡¦ç†
            if (enemy.type.name === 'ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼') {
              if (!enemy.chargeState) {
                enemy.chargeState = 'idle';
                enemy.lastChargeTime = currentTime;
                enemy.chargeDirection = null;
              }

              if (enemy.chargeState === 'idle' && currentTime - enemy.lastChargeTime >= enemy.type.chargeInterval) {
                // çªé€²æº–å‚™é–‹å§‹
                enemy.chargeState = 'preparing';
                enemy.prepareStartTime = currentTime;
                
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ–¹å‘ã‚’è¨˜éŒ²
                const dx = this.player.position.x - enemy.position.x;
                const dy = this.player.position.y - enemy.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                enemy.chargeDirection = { x: dx / distance, y: dy / distance };
              } else if (enemy.chargeState === 'preparing' && currentTime - enemy.prepareStartTime >= 500) {
                // çªé€²é–‹å§‹
                enemy.chargeState = 'charging';
                enemy.chargeStartTime = currentTime;
              } else if (enemy.chargeState === 'charging' && currentTime - enemy.chargeStartTime >= enemy.type.chargeDuration) {
                // çªé€²çµ‚äº†
                enemy.chargeState = 'idle';
                enemy.lastChargeTime = currentTime;
                enemy.chargeDirection = null;
              }
            }

            // ãƒ‡ãƒãƒ•æ•µã®ç¯„å›²ãƒ‡ãƒãƒ•å‡¦ç†
            if (enemy.type.name === 'ãƒ‡ãƒãƒ•æ•µ') {
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < enemy.type.debuffRange) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é…ãã™ã‚‹
                if (!this.debuffedByEnemy) {
                  this.debuffedByEnemy = true;
                }
              }
            }

            // ç§»å‹•å‡¦ç†
            let moveSpeed = enemy.speed;
            
            if (enemy.type.name === 'ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼' && enemy.chargeState === 'charging' && enemy.chargeDirection) {
              // çªé€²ä¸­ã¯é«˜é€Ÿç§»å‹•
              enemy.velocity.x = enemy.chargeDirection.x * enemy.type.chargeSpeed * 50;
              enemy.velocity.y = enemy.chargeDirection.y * enemy.type.chargeSpeed * 50;
            } else if (enemy.type.name === 'ãƒãƒ£ãƒ¼ã‚¸ãƒ£ãƒ¼' && enemy.chargeState === 'preparing') {
              // æº–å‚™ä¸­ã¯åœæ­¢
              enemy.velocity.x = 0;
              enemy.velocity.y = 0;
            } else {
              // é€šå¸¸ç§»å‹•
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance > 0) {
                enemy.velocity.x = (dx / distance) * moveSpeed * 50;
                enemy.velocity.y = (dy / distance) * moveSpeed * 50;
              }
            }

            enemy.position.x += enemy.velocity.x * deltaTime;
            enemy.position.y += enemy.velocity.y * deltaTime;

            // ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼ã®ç…§æº–æ›´æ–°
            if (enemy.type.name === 'ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼' || enemy.type.name === 'ä¸­ãƒœã‚¹' || enemy.type.name === 'æœ€çµ‚ãƒœã‚¹') {
              enemy.targetX = this.player.position.x;
              enemy.targetY = this.player.position.y;
            }

            if (enemy.damageFlash > 0) {
              enemy.damageFlash -= deltaTime * 1000;
            }

            // ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼ç³»ã®æ•µã®å°„æ’ƒ
            if ((enemy.type.name === 'ã‚·ãƒ¥ãƒ¼ã‚¿ãƒ¼' || enemy.type.name === 'ä¸­ãƒœã‚¹' || enemy.type.name === 'æœ€çµ‚ãƒœã‚¹') && 
                currentTime - enemy.lastShootTime >= enemy.type.shootInterval) {
              this.enemyShoot(enemy);
              enemy.lastShootTime = currentTime;
            }
          });

          // ãƒ‡ãƒãƒ•è§£é™¤ãƒã‚§ãƒƒã‚¯
          this.debuffedByEnemy = false;
          this.enemies.forEach(enemy => {
            if (enemy.isAlive && enemy.type.name === 'ãƒ‡ãƒãƒ•æ•µ') {
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < enemy.type.debuffRange) {
                this.debuffedByEnemy = true;
              }
            }
          });

          this.enemies = this.enemies.filter(e => e.isAlive);
        }

        enemyShoot(enemy) {
          const dx = this.player.position.x - enemy.position.x;
          const dy = this.player.position.y - enemy.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance === 0) return;

          const speed = 200;
          this.enemyProjectiles.push({
            position: { x: enemy.position.x, y: enemy.position.y },
            velocity: { x: (dx / distance) * speed, y: (dy / distance) * speed },
            radius: 5,
            damage: enemy.type.damage,
            isAlive: true,
          });
        }

        updateProjectiles(deltaTime) {
          this.projectiles.forEach(proj => {
            if (!proj.isAlive) return;

            proj.position.x += proj.velocity.x * deltaTime;
            proj.position.y += proj.velocity.y * deltaTime;

            if (proj.position.x < 0 || proj.position.x > this.canvas.width ||
                proj.position.y < 0 || proj.position.y > this.canvas.height) {
              proj.isAlive = false;
            }
          });

          this.projectiles = this.projectiles.filter(p => p.isAlive);
        }

        updateEnemyProjectiles(deltaTime) {
          this.enemyProjectiles.forEach(proj => {
            if (!proj.isAlive) return;

            proj.position.x += proj.velocity.x * deltaTime;
            proj.position.y += proj.velocity.y * deltaTime;

            if (proj.position.x < 0 || proj.position.x > this.canvas.width ||
                proj.position.y < 0 || proj.position.y > this.canvas.height) {
              proj.isAlive = false;
            }
          });

          this.enemyProjectiles = this.enemyProjectiles.filter(p => p.isAlive);
        }

        updateXPOrbs(deltaTime) {
          const magnetActive = this.activeEffects.magnet > performance.now();
          const magnetRadius = magnetActive ? 200 : 100;

          this.xpOrbs.forEach(orb => {
            const dx = this.player.position.x - orb.position.x;
            const dy = this.player.position.y - orb.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < magnetRadius) {
              const speed = magnetActive ? 400 : 200;
              orb.position.x += (dx / distance) * speed * deltaTime;
              orb.position.y += (dy / distance) * speed * deltaTime;
            }
          });
        }

        updateItems(deltaTime) {
          this.items.forEach(item => {
            if (!item.isAlive) return;

            item.lifetime += deltaTime * 1000;
            if (item.lifetime > 15000) {
              item.isAlive = false;
            }
          });

          this.items = this.items.filter(i => i.isAlive);
        }

        updateEffects(currentTime) {
          Object.keys(this.activeEffects).forEach(key => {
            if (this.activeEffects[key] > 0 && this.activeEffects[key] < currentTime) {
              this.activeEffects[key] = 0;
            }
          });
        }

        shoot(currentTime) {
          const shootDelay = 1000 / this.player.attackSpeed;

          if (currentTime - this.lastShootTime < shootDelay) return;

          const nearestEnemy = this.findNearestEnemy();
          if (!nearestEnemy) return;

          const dx = nearestEnemy.position.x - this.player.position.x;
          const dy = nearestEnemy.position.y - this.player.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > this.player.range) return;

          const powerUpActive = this.activeEffects.powerUp > currentTime;
          const damageMultiplier = powerUpActive ? 2.0 : 1.0;

          // è¤‡æ•°ã®å¼¾ã‚’ç™ºå°„
          const count = this.player.projectileCount;
          
          for (let i = 0; i < count; i++) {
            let finalAngle;
            
            if (i === 0) {
              // 1ç™ºç›®ã¯æ•µã«å‘ã‹ã£ã¦ç™ºå°„
              finalAngle = Math.atan2(dy, dx);
            } else {
              // 2ç™ºç›®ä»¥é™ã¯ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘
              finalAngle = Math.random() * Math.PI * 2;
            }
            
            this.projectiles.push({
              position: { x: this.player.position.x, y: this.player.position.y },
              velocity: { 
                x: Math.cos(finalAngle) * this.player.projectileSpeed, 
                y: Math.sin(finalAngle) * this.player.projectileSpeed 
              },
              radius: 5 * this.player.projectileSize,
              damage: this.player.damage * damageMultiplier,
              piercing: this.player.piercing,
              isAlive: true,
            });
          }

          this.lastShootTime = currentTime;
        }

        findNearestEnemy() {
          let nearest = null;
          let minDist = Infinity;

          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            const dx = enemy.position.x - this.player.position.x;
            const dy = enemy.position.y - this.player.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < minDist) {
              minDist = dist;
              nearest = enemy;
            }
          });

          return nearest;
        }

        spawnEnemies(currentTime) {
          // è»½é‡ç‰ˆã§ã¯æ•µã®æœ€å¤§æ•°ã‚’åˆ¶é™(å°‘ã—å¢—ã‚„ã—ãŸ)
          const maxEnemies = this.isLowSpec ? 25 : 50;
          const activeEnemies = this.enemies.filter(e => e.isAlive).length;
          
          if (activeEnemies >= maxEnemies) {
            return; // æ•µãŒå¤šã™ãã‚‹å ´åˆã¯ã‚¹ãƒãƒ¼ãƒ³ã—ãªã„
          }
          
          if (currentTime - this.lastEnemySpawnTime > this.enemySpawnInterval) {
            // è»½é‡ç‰ˆã§ã‚‚æ•µã®æ•°ã‚’ç¢ºä¿(ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å¢—åŠ )
            const baseCount = this.isLowSpec 
              ? Math.min(2, 1 + Math.floor(this.gameTime / 60000)) // 1åˆ†ã”ã¨ã«1ä½“å¢—åŠ 
              : Math.min(3, 1 + Math.floor(this.gameTime / 45000));
            const count = baseCount;
            
            for (let i = 0; i < count; i++) {
              // æœ€å¤§æ•°ãƒã‚§ãƒƒã‚¯
              if (this.enemies.filter(e => e.isAlive).length >= maxEnemies) {
                break;
              }
              this.spawnEnemy();
            }
            
            this.lastEnemySpawnTime = currentTime;
            // è»½é‡ç‰ˆã§ã‚‚å‡ºç¾é–“éš”ã‚’å°‘ã—çŸ­ã
            const baseInterval = this.isLowSpec ? 1500 : 1500;
            this.enemySpawnInterval = Math.max(this.isLowSpec ? 1000 : 800, baseInterval - this.gameTime / 150);
          }
        }

        spawnEnemy() {
          const type = getRandomEnemyType(this.player.level);
          const side = Math.floor(Math.random() * 4);
          let x, y;

          switch (side) {
            case 0: x = Math.random() * this.canvas.width; y = -20; break;
            case 1: x = this.canvas.width + 20; y = Math.random() * this.canvas.height; break;
            case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 20; break;
            case 3: x = -20; y = Math.random() * this.canvas.height; break;
          }

          // è»½é‡ç‰ˆã§ã¯æ•µã‚’å¼·åŒ–ã—ã¦ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚‹
          const hpMultiplier = 1.0; // HPã¯ä¸Šã’ãªã„
          const speedMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const damageMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const xpMultiplier = this.isLowSpec ? 1.8 : 1.0; // çµŒé¨“å€¤ã‚‚å¢—ã‚„ã™

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 15,
            speed: type.speed * speedMultiplier,
            hp: type.hp * hpMultiplier,
            maxHp: type.hp * hpMultiplier,
            damage: type.damage * damageMultiplier,
            xpValue: Math.floor(type.xp * xpMultiplier),
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: type.splitCount || 0,
          });
        }

        spawnMiniBoss() {
          const type = ENEMY_TYPES.MINIBOSS;
          const side = Math.floor(Math.random() * 4);
          let x, y;

          switch (side) {
            case 0: x = this.canvas.width / 2; y = -30; break;
            case 1: x = this.canvas.width + 30; y = this.canvas.height / 2; break;
            case 2: x = this.canvas.width / 2; y = this.canvas.height + 30; break;
            case 3: x = -30; y = this.canvas.height / 2; break;
          }

          // è»½é‡ç‰ˆã§ã¯ä¸­ãƒœã‚¹ã‚‚å¼·åŒ–
          const hpMultiplier = 1.0; // HPã¯ä¸Šã’ãªã„
          const damageMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const xpMultiplier = this.isLowSpec ? 1.5 : 1.0;

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 30,
            speed: type.speed,
            hp: type.hp * hpMultiplier,
            maxHp: type.hp * hpMultiplier,
            damage: type.damage * damageMultiplier,
            xpValue: Math.floor(type.xp * xpMultiplier),
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: 0,
          });
        }

        spawnFinalBoss() {
          const type = ENEMY_TYPES.FINALBOSS;
          
          // ç”»é¢ä¸­å¤®ä¸Šã‹ã‚‰ç™»å ´
          const x = this.canvas.width / 2;
          const y = -50;

          // è»½é‡ç‰ˆã§ã¯æœ€çµ‚ãƒœã‚¹ã‚‚å¼·åŒ–
          const hpMultiplier = 1.0; // HPã¯ä¸Šã’ãªã„
          const damageMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const xpMultiplier = this.isLowSpec ? 1.5 : 1.0;

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 50,
            speed: type.speed,
            hp: type.hp * hpMultiplier,
            maxHp: type.hp * hpMultiplier,
            damage: type.damage * damageMultiplier,
            xpValue: Math.floor(type.xp * xpMultiplier),
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: 0,
          });
          
          // æœ€çµ‚ãƒœã‚¹BGMã«åˆ‡ã‚Šæ›¿ãˆ
          this.playBGM('finalboss');
        }

        checkCollisions() {
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã¨æ•µ
          this.projectiles.forEach(proj => {
            if (!proj.isAlive) return;

            this.enemies.forEach(enemy => {
              if (!enemy.isAlive) return;

              const dx = proj.position.x - enemy.position.x;
              const dy = proj.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < proj.radius + enemy.radius) {
                enemy.hp -= proj.damage;
                enemy.damageFlash = 200;
                this.stats.damageDealt += proj.damage;
                
                // æ•µã«æ”»æ’ƒãŒå½“ãŸã£ãŸåŠ¹æœéŸ³
                this.playSFX('enemyHit');

                if (proj.piercing > 0) {
                  proj.piercing--;
                } else {
                  proj.isAlive = false;
                }

                if (enemy.hp <= 0) {
                  enemy.isAlive = false;
                  this.stats.enemiesKilled++;
                  
                  // ãƒœã‚¹æ’ƒç ´ã®åŠ¹æœéŸ³
                  if (enemy.type.name === 'ä¸­ãƒœã‚¹' || enemy.type.name === 'æœ€çµ‚ãƒœã‚¹') {
                    this.playSFX('bossDeath');
                  } else {
                    // é€šå¸¸æ•µæ’ƒç ´ã®åŠ¹æœéŸ³
                    this.playSFX('enemyDeath');
                  }
                  
                  this.spawnXPOrb(enemy.position.x, enemy.position.y, enemy.xpValue, enemy.type.name === 'ä¸­ãƒœã‚¹' || enemy.type.name === 'æœ€çµ‚ãƒœã‚¹');

                  // æœ€çµ‚ãƒœã‚¹ã‚’å€’ã—ãŸã‚‰ã‚¯ãƒªã‚¢
                  if (enemy.type.name === 'æœ€çµ‚ãƒœã‚¹') {
                    this.gameClear();
                    return;
                  }

                  // ã‚¹ãƒ—ãƒªãƒƒã‚¿ãƒ¼ã¯å€’ã™ã¨åˆ†è£‚ã™ã‚‹
                  if (enemy.type.name === 'ã‚¹ãƒ—ãƒªãƒƒã‚¿ãƒ¼' && enemy.splitCount && enemy.splitCount > 0) {
                    for (let i = 0; i < enemy.type.splitCount; i++) {
                      const angle = (Math.PI * 2 / enemy.type.splitCount) * i;
                      const offsetX = Math.cos(angle) * 30;
                      const offsetY = Math.sin(angle) * 30;
                      
                      this.enemies.push({
                        type: enemy.type,
                        position: { x: enemy.position.x + offsetX, y: enemy.position.y + offsetY },
                        velocity: { x: 0, y: 0 },
                        radius: enemy.radius * 0.7,
                        speed: enemy.speed * 1.2,
                        hp: enemy.maxHp * 0.5,
                        maxHp: enemy.maxHp * 0.5,
                        damage: enemy.damage * 0.7,
                        xpValue: Math.ceil(enemy.xpValue * 0.5),
                        isAlive: true,
                        damageFlash: 0,
                        lastShootTime: 0,
                        targetX: this.player.position.x,
                        targetY: this.player.position.y,
                        splitCount: 0, // åˆ†è£‚æ¸ˆã¿ã¯ã‚‚ã†åˆ†è£‚ã—ãªã„
                      });
                    }
                  }

                  if (Math.random() < 0.1) {
                    this.spawnItem(enemy.position.x, enemy.position.y);
                  }
                }
              }
            });
          });

          // æ•µã®å¼¾ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
          this.enemyProjectiles.forEach(proj => {
            if (!proj.isAlive) return;

            const dx = proj.position.x - this.player.position.x;
            const dy = proj.position.y - this.player.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < proj.radius + this.player.radius) {
              proj.isAlive = false;
              this.damagePlayer(proj.damage, performance.now());
            }
          });

          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨çµŒé¨“å€¤ã‚ªãƒ¼ãƒ–
          this.xpOrbs.forEach((orb, index) => {
            const dx = this.player.position.x - orb.position.x;
            const dy = this.player.position.y - orb.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + orb.radius) {
              this.player.xp += orb.value;
              this.xpOrbs.splice(index, 1);
              // ã‚ªãƒ¼ãƒ–å–å¾—åŠ¹æœéŸ³
              this.playSFX('gemGet');
              this.updateUI();
              this.checkLevelUp();
            }
          });

          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚¢ã‚¤ãƒ†ãƒ 
          this.items.forEach((item, index) => {
            if (!item.isAlive) return;

            const dx = this.player.position.x - item.position.x;
            const dy = this.player.position.y - item.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + item.radius) {
              this.applyItemEffect(item);
              item.isAlive = false;
              // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—åŠ¹æœéŸ³
              this.playSFX('itemGet');
            }
          });

          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨æ•µã®æ¥è§¦
          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            const dx = this.player.position.x - enemy.position.x;
            const dy = this.player.position.y - enemy.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + enemy.radius) {
              this.damagePlayer(enemy.damage, performance.now());
            }
          });
        }

        damagePlayer(damage, currentTime) {
          // ç„¡æ•µæ™‚é–“ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãªã„
          if (this.activeEffects.invincible > currentTime) return;
          
          // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãªã„
          if (currentTime - this.player.lastDamageTime < this.player.damageCooldown) return;

          if (this.player.shield > 0) {
            this.player.shield = Math.max(0, this.player.shield - damage);
            this.player.lastDamageTime = currentTime;
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸åŠ¹æœéŸ³
            this.playSFX('playerHit');
            return;
          }

          this.player.hp = Math.max(0, this.player.hp - damage);
          this.player.lastDamageTime = currentTime;
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸åŠ¹æœéŸ³
          this.playSFX('playerHit');
          this.updateUI();

          if (this.player.hp <= 0) {
            this.gameOver();
          }
        }

        spawnXPOrb(x, y, value, isBossOrb = false) {
          this.xpOrbs.push({
            position: { x, y },
            radius: isBossOrb ? 12 : 6,
            value: value,
            isBossOrb: isBossOrb,
          });
        }

        spawnItem(x, y) {
          const items = [
            { type: 'heal', emoji: 'â¤ï¸', color: '#ff6b6b', name: 'å›å¾©' },
            { type: 'speedBoost', emoji: 'âš¡', color: '#feca57', name: 'ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆ' },
            { type: 'powerUp', emoji: 'ğŸ’ª', color: '#ff6348', name: 'ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—' },
            { type: 'timeSlow', emoji: 'ğŸŒ€', color: '#5f27cd', name: 'ã‚¿ã‚¤ãƒ ã‚¹ãƒ­ãƒ¼' },
            { type: 'invincible', emoji: 'âœ¨', color: '#ff9ff3', name: 'ç„¡æ•µ' },
            { type: 'magnet', emoji: 'ğŸ¯', color: '#54a0ff', name: 'ãƒã‚°ãƒãƒƒãƒˆ' },
          ];

          const item = items[Math.floor(Math.random() * items.length)];
          
          this.items.push({
            ...item,
            position: { x, y },
            radius: 12,
            isAlive: true,
            lifetime: 0,
          });
        }

        applyItemEffect(item) {
          const currentTime = performance.now();
          
          this.itemNotification = item;
          this.itemNotificationTime = currentTime;

          switch (item.type) {
            case 'heal':
              this.player.hp = Math.min(this.player.maxHp, this.player.hp + 30);
              break;
            case 'speedBoost':
              this.activeEffects.speedBoost = currentTime + 5000;
              break;
            case 'powerUp':
              this.activeEffects.powerUp = currentTime + 8000;
              break;
            case 'timeSlow':
              this.activeEffects.timeSlow = currentTime + 5000;
              break;
            case 'invincible':
              this.activeEffects.invincible = currentTime + 3000;
              this.player.invincibleUntil = currentTime + 3000;
              break;
            case 'magnet':
              this.activeEffects.magnet = currentTime + 10000;
              break;
          }

          this.updateUI();
        }

        checkLevelUp() {
          if (this.player.xp >= this.player.xpToNextLevel) {
            this.player.xp -= this.player.xpToNextLevel;
            this.player.level++;
            
            // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã«å¿…è¦ãªçµŒé¨“å€¤ã®å¢—åŠ ç‡
            let xpMultiplier = 1.3;
            
            // ã‚¹ãƒãƒ›ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã§ãƒ¬ãƒ™ãƒ«18ä»¥é™ã¯å¢—åŠ ç‡ã‚’ç·©å’Œ
            if (this.isLowSpec || this.isUltraLowSpec) {
              if (this.player.level >= 18) {
                xpMultiplier = 1.15; // 18ãƒ¬ãƒ™ãƒ«ä»¥é™ã¯1.15å€ã«
              } else if (this.player.level >= 15) {
                xpMultiplier = 1.2; // 15-17ãƒ¬ãƒ™ãƒ«ã¯1.2å€ã«
              }
            }
            
            this.player.xpToNextLevel = Math.floor(this.player.xpToNextLevel * xpMultiplier);
            
            // ãƒ¬ãƒ™ãƒ«10ä»¥é™ã¯ä¸­ãƒœã‚¹ã®å‡ºç¾é »åº¦ã‚’ä¸Šã’ã‚‹
            let miniBossInterval = 5; // åŸºæœ¬ã¯5ãƒ¬ãƒ™ãƒ«ã”ã¨
            if (this.player.level >= 10) {
              miniBossInterval = this.isLowSpec ? 2 : 3; // è»½é‡ç‰ˆã¯2ãƒ¬ãƒ™ãƒ«ã”ã¨ã€é€šå¸¸ç‰ˆã¯3ãƒ¬ãƒ™ãƒ«ã”ã¨
            }
            
            // ä¸­ãƒœã‚¹å‡ºç¾
            if (this.player.level % miniBossInterval === 0 && this.player.level < 20 && this.player.level > this.lastBossLevel) {
              this.spawnMiniBoss();
              this.lastBossLevel = this.player.level;
            }
            
            // ãƒ¬ãƒ™ãƒ«20ã§æœ€çµ‚ãƒœã‚¹å‡ºç¾
            if (this.player.level === 20 && !this.finalBossSpawned) {
              this.spawnFinalBoss();
              this.finalBossSpawned = true;
            }
            
            this.isPaused = true;
            this.showLevelUpModal();
            this.updateUI();
          }
        }

        showLevelUpModal() {
          const upgrades = [
            { 
              id: 'damage', 
              name: 'âœ¨ æ”»æ’ƒåŠ›ã‚¢ãƒƒãƒ—', 
              description: 'ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒ20%å¢—åŠ ',
              apply: () => this.player.damage *= 1.20
            },
            { 
              id: 'attackSpeed', 
              name: 'âš¡ æ”»æ’ƒé€Ÿåº¦ã‚¢ãƒƒãƒ—', 
              description: 'æ”»æ’ƒé–“éš”ãŒçŸ­ããªã‚‹ï¼ˆ20%UPï¼‰',
              apply: () => this.player.attackSpeed *= 1.2
            },
            { 
              id: 'speed', 
              name: 'ğŸƒ ç§»å‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—', 
              description: 'é€Ÿãå‹•ã‘ã‚‹ã‚ˆã†ã«ãªã‚‹ï¼ˆ15%UPï¼‰',
              apply: () => this.player.speed *= 1.15
            },
            { 
              id: 'maxHp', 
              name: 'â¤ï¸ æœ€å¤§HPã‚¢ãƒƒãƒ—', 
              description: 'æœ€å¤§HPãŒ20å¢—ãˆã¦å…¨å›å¾©',
              apply: () => {
                this.player.maxHp += 20;
                this.player.hp = this.player.maxHp;
              }
            },
            { 
              id: 'projectileCount', 
              name: 'ğŸŒŸ å¼¾æ•°å¢—åŠ ', 
              description: 'æµã‚Œæ˜Ÿã®æ•°ãŒ1ã¤å¢—ãˆã‚‹ï¼ˆ1ç™ºã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯20%æ¸›ï¼‰',
              apply: () => {
                this.player.projectileCount += 1;
                this.player.damage *= 0.8; // 1ç™ºã‚ãŸã‚Šã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’20%æ¸›å°‘
              }
            },
            { 
              id: 'piercing', 
              name: 'ğŸ’¥ è²«é€šåŠ›ã‚¢ãƒƒãƒ—', 
              description: 'æµã‚Œæ˜ŸãŒæ•µã‚’è²«é€šã™ã‚‹ï¼ˆ+1ï¼‰',
              apply: () => this.player.piercing += 1
            },
          ];

          const selected = [];
          while (selected.length < 3) {
            const upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
            if (!selected.includes(upgrade)) {
              selected.push(upgrade);
            }
          }

          this.upgradeOptions.innerHTML = '';
          selected.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.innerHTML = `
              <h3>${upgrade.name}</h3>
              <p>${upgrade.description}</p>
            `;
            card.addEventListener('click', () => {
              upgrade.apply();
              this.updateUI();
              this.levelupModal.classList.add('hidden');
              this.isPaused = false;
              this.lastTime = performance.now();
              this.gameLoop(this.lastTime);
            });
            this.upgradeOptions.appendChild(card);
          });

          this.levelupModal.classList.remove('hidden');
        }

        updateUI() {
          this.hpFill.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
          this.hpText.textContent = `${Math.floor(this.player.hp)}/${this.player.maxHp}`;

          this.xpFill.style.width = `${(this.player.xp / this.player.xpToNextLevel) * 100}%`;
          this.xpText.textContent = `${Math.floor(this.player.xp)}/${this.player.xpToNextLevel}`;

          this.levelText.textContent = this.player.level;
        }

        updateBuffsUI() {
          const currentTime = performance.now();
          this.buffsContainer.innerHTML = '';
          
          const activeBuffs = [];
          
          if (this.activeEffects.speedBoost) {
            activeBuffs.push({
              name: 'ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ–ãƒ¼ã‚¹ãƒˆ',
              emoji: 'âš¡',
              color: '#feca57',
              endTime: this.activeEffects.speedBoost,
              duration: 5000,
            });
          }
          
          if (this.activeEffects.powerUp) {
            activeBuffs.push({
              name: 'ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—',
              emoji: 'ğŸ’ª',
              color: '#ff6348',
              endTime: this.activeEffects.powerUp,
              duration: 8000,
            });
          }
          
          if (this.activeEffects.timeSlow) {
            activeBuffs.push({
              name: 'ã‚¿ã‚¤ãƒ ã‚¹ãƒ­ãƒ¼',
              emoji: 'ğŸŒ€',
              color: '#5f27cd',
              endTime: this.activeEffects.timeSlow,
              duration: 5000,
            });
          }
          
          if (this.activeEffects.invincible) {
            activeBuffs.push({
              name: 'ç„¡æ•µ',
              emoji: 'âœ¨',
              color: '#ff9ff3',
              endTime: this.activeEffects.invincible,
              duration: 3000,
            });
          }
          
          if (this.activeEffects.magnet) {
            activeBuffs.push({
              name: 'ãƒã‚°ãƒãƒƒãƒˆ',
              emoji: 'ğŸ¯',
              color: '#54a0ff',
              endTime: this.activeEffects.magnet,
              duration: 10000,
            });
          }
          
          if (this.player.shield && this.player.shield > 0) {
            activeBuffs.push({
              name: 'ã‚·ãƒ¼ãƒ«ãƒ‰',
              emoji: 'ğŸ›¡ï¸',
              color: '#48dbfb',
              endTime: null,
              duration: null,
            });
          }
          
          activeBuffs.forEach(buff => {
            const buffEl = document.createElement('div');
            buffEl.className = 'buff-item';
            buffEl.style.borderColor = buff.color;
            
            let timerHTML = '';
            if (buff.endTime) {
              const remaining = Math.max(0, buff.endTime - currentTime);
              const percent = (remaining / buff.duration) * 100;
              timerHTML = `
                <div class="buff-timer">
                  <div class="buff-timer-fill" style="width: ${percent}%; background: ${buff.color}"></div>
                </div>
              `;
            }
            
            buffEl.innerHTML = `
              <span class="buff-icon">${buff.emoji}</span>
              <div class="buff-info">
                <div class="buff-name">${buff.name}</div>
                ${timerHTML}
              </div>
            `;
            
            this.buffsContainer.appendChild(buffEl);
          });
        }

        gameOver() {
          this.isGameOver = true;
          this.stats.timeAlive = this.gameTime;
          this.stats.level = this.player.level;
          this.stopBGM();
          
          // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼BGMã‚’å†ç”Ÿ
          this.playBGM('gameover');

          const statsText = `
            ç”Ÿå­˜æ™‚é–“: ${formatTime(this.stats.timeAlive)}<br>
            ãƒ¬ãƒ™ãƒ«: ${this.stats.level}<br>
            å€’ã—ãŸæ•µ: ${this.stats.enemiesKilled}ä½“<br>
            ä¸ãˆãŸãƒ€ãƒ¡ãƒ¼ã‚¸: ${Math.floor(this.stats.damageDealt)}
          `;
          
          document.getElementById('final-stats').innerHTML = statsText;
          this.gameoverModal.classList.remove('hidden');
        }

        gameClear() {
          this.isGameOver = true;
          this.stats.timeAlive = this.gameTime;
          this.stats.level = this.player.level;
          this.stopBGM();
          
          // ã‚¯ãƒªã‚¢BGMã‚’å†ç”Ÿ
          this.playBGM('clear');

          const statsText = `
            ã‚¯ãƒªã‚¢æ™‚é–“: ${formatTime(this.stats.timeAlive)}<br>
            æœ€çµ‚ãƒ¬ãƒ™ãƒ«: ${this.stats.level}<br>
            å€’ã—ãŸæ•µ: ${this.stats.enemiesKilled}ä½“<br>
            ä¸ãˆãŸãƒ€ãƒ¡ãƒ¼ã‚¸: ${Math.floor(this.stats.damageDealt)}
          `;
          
          document.getElementById('clear-stats').innerHTML = statsText;
          this.gameclearModal.classList.remove('hidden');
        }

        render() {
          const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
          gradient.addColorStop(0, '#0f0c29');
          gradient.addColorStop(0.5, '#302b63');
          gradient.addColorStop(1, '#24243e');
          
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // è»½é‡ç‰ˆã§ã¯æ˜Ÿã®æ•°ã‚’å‰Šæ¸›ï¼ˆã‚¹ãƒãƒ›ã¯è¶…å‰Šæ¸›ï¼‰
          this.ctx.fillStyle = '#ffffff';
          const starCount = this.isUltraLowSpec ? 10 : (this.isLowSpec ? 20 : 50);
          for (let i = 0; i < starCount; i++) {
            const x = (i * 137.5) % this.canvas.width;
            const y = (i * 213.7) % this.canvas.height;
            this.ctx.fillRect(x, y, 1, 1);
          }

          this.xpOrbs.forEach(orb => {
            this.ctx.save();
            
            const time = performance.now() / 300;
            const pulse = Math.sin(time) * 0.2 + 1;
            
            if (orb.isBossOrb) {
              // ä¸­ãƒœã‚¹ã‚ªãƒ¼ãƒ–: ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
              this.ctx.shadowColor = '#ffd700';
              this.ctx.shadowBlur = this.isLowSpec ? 10 : 25;
              
              const angle = time % (Math.PI * 2);
              const gradient = this.ctx.createRadialGradient(
                orb.position.x, orb.position.y, 0,
                orb.position.x, orb.position.y, orb.radius * pulse
              );
              
              const hue = (time * 50) % 360;
              gradient.addColorStop(0, `hsl(${hue}, 100%, 90%)`);
              gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 100%, 70%)`);
              gradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
              
              this.ctx.beginPath();
              this.ctx.arc(orb.position.x, orb.position.y, orb.radius * pulse, 0, Math.PI * 2);
              this.ctx.fillStyle = gradient;
              this.ctx.fill();
              
              this.ctx.strokeStyle = '#ffd700';
              this.ctx.lineWidth = 3;
              this.ctx.stroke();
              
              // ã‚­ãƒ©ã‚­ãƒ©æ˜Ÿ(è»½é‡ç‰ˆã§ã¯çœç•¥)
              if (!this.isLowSpec) {
                for (let i = 0; i < 4; i++) {
                  const starAngle = angle + (i * Math.PI / 2);
                  const starDist = orb.radius * pulse + 5;
                  const starX = orb.position.x + Math.cos(starAngle) * starDist;
                  const starY = orb.position.y + Math.sin(starAngle) * starDist;
                  
                  this.ctx.fillStyle = '#ffffff';
                  this.ctx.beginPath();
                  this.ctx.arc(starX, starY, 3, 0, Math.PI * 2);
                  this.ctx.fill();
                }
              }
            } else {
              // é€šå¸¸ã‚ªãƒ¼ãƒ–
              if (this.isLowSpec) {
                // è»½é‡ç‰ˆ: ã‚·ãƒ³ãƒ—ãƒ«ãªå††
                // ã‚¹ãƒãƒ›ã¯shadowBlurãªã—
                if (!this.isUltraLowSpec) {
                  this.ctx.shadowColor = '#00ffff';
                  this.ctx.shadowBlur = 8;
                }
                
                this.ctx.beginPath();
                this.ctx.arc(orb.position.x, orb.position.y, orb.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = '#00ffff';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
              } else {
                // é€šå¸¸ç‰ˆ: å…­è§’å½¢
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 15;
                
                const gradient = this.ctx.createRadialGradient(
                  orb.position.x, orb.position.y, 0,
                  orb.position.x, orb.position.y, orb.radius * pulse
                );
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.4, '#00ffff');
                gradient.addColorStop(1, '#00cccc');
                
                // å…­è§’å½¢
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                  const angle = (Math.PI / 3) * i + time;
                  const x = orb.position.x + Math.cos(angle) * orb.radius * pulse;
                  const y = orb.position.y + Math.sin(angle) * orb.radius * pulse;
                  if (i === 0) this.ctx.moveTo(x, y);
                  else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // ä¸­å¿ƒã«å…‰ã‚‹ç‚¹
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(orb.position.x, orb.position.y, 2, 0, Math.PI * 2);
                this.ctx.fill();
              }
            }
            
            this.ctx.restore();
          });

          this.items.forEach(item => {
            if (item.isAlive) {
              drawItem(this.ctx, item);
            }
          });

          this.enemies.forEach(enemy => {
            if (enemy.isAlive) {
              drawEnemy(this.ctx, enemy);
            }
          });

          this.enemyProjectiles.forEach(proj => {
            if (proj.isAlive) {
              this.ctx.save();
              
              if (this.isLowSpec) {
                // è»½é‡ç‰ˆ: ã‚·ãƒ³ãƒ—ãƒ«ãªèµ¤ã„å††
                // ã‚¹ãƒãƒ›ã¯shadowBlurãªã—
                if (!this.isUltraLowSpec) {
                  this.ctx.shadowColor = '#ff0000';
                  this.ctx.shadowBlur = 10;
                }
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = '#ff3333';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffaaaa';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
              } else {
                // é€šå¸¸ç‰ˆ: æ´¾æ‰‹ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                // å¤–å´ã®å¼·ã„å…‰
                this.ctx.shadowColor = '#ff0000';
                this.ctx.shadowBlur = 25;
                
                // å…‰ã®ã‚ªãƒ¼ãƒ©ï¼ˆå¤–å´ï¼‰
                const outerGradient = this.ctx.createRadialGradient(
                  proj.position.x, proj.position.y, 0,
                  proj.position.x, proj.position.y, proj.radius * 3
                );
                outerGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                outerGradient.addColorStop(0.4, 'rgba(255, 50, 50, 0.4)');
                outerGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius * 3, 0, Math.PI * 2);
                this.ctx.fillStyle = outerGradient;
                this.ctx.fill();
                
                // æœ¬ä½“ï¼ˆæ˜ã‚‹ãï¼‰
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = '#ff3333';
                
                const bodyGradient = this.ctx.createRadialGradient(
                  proj.position.x, proj.position.y, 0,
                  proj.position.x, proj.position.y, proj.radius
                );
                bodyGradient.addColorStop(0, '#ffaaaa');
                bodyGradient.addColorStop(0.6, '#ff3333');
                bodyGradient.addColorStop(1, '#cc0000');
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = bodyGradient;
                this.ctx.fill();
                
                // ä¸­å¿ƒã®å¼·ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                const highlightGradient = this.ctx.createRadialGradient(
                  proj.position.x - proj.radius * 0.3, 
                  proj.position.y - proj.radius * 0.3, 
                  0,
                  proj.position.x, 
                  proj.position.y, 
                  proj.radius * 0.6
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = highlightGradient;
                this.ctx.fill();
                
                // å…‰ã‚‹ç¸å–ã‚Š
                this.ctx.strokeStyle = '#ffaaaa';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
              }
              
              this.ctx.restore();
            }
          });

          this.projectiles.forEach(proj => {
            if (proj.isAlive) {
              this.ctx.save();
              this.ctx.translate(proj.position.x, proj.position.y);
              
              const spikes = 5;
              const outerRadius = proj.radius;
              const innerRadius = proj.radius / 2;

              this.ctx.beginPath();
              for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (Math.PI / spikes) * i;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) {
                  this.ctx.moveTo(x, y);
                } else {
                  this.ctx.lineTo(x, y);
                }
              }
              this.ctx.closePath();
              
              this.ctx.fillStyle = '#ffd700';
              this.ctx.fill();
              this.ctx.strokeStyle = '#ffed4e';
              this.ctx.lineWidth = 1;
              this.ctx.stroke();

              this.ctx.restore();
            }
          });

          drawPlayer(this.ctx, this.player, this.playerImage, performance.now(), this.isLowSpec, this.isUltraLowSpec);

          if (this.itemNotification) {
            const elapsed = performance.now() - this.itemNotificationTime;
            if (elapsed < 2000) {
              this.ctx.save();
              
              const alpha = elapsed < 1500 ? 1 : 1 - (elapsed - 1500) / 500;
              this.ctx.globalAlpha = alpha;
              
              const y = this.canvas.height / 2 - 100 - (elapsed / 10);
              
              this.ctx.font = 'bold 24px Arial';
              this.ctx.textAlign = 'center';
              this.ctx.textBaseline = 'middle';
              
              this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
              this.ctx.fillRect(this.canvas.width / 2 - 120, y - 20, 240, 50);
              
              this.ctx.fillStyle = this.itemNotification.color;
              this.ctx.fillText(`${this.itemNotification.emoji} ${this.itemNotification.name}`, this.canvas.width / 2, y);
              
              this.ctx.restore();
            } else {
              this.itemNotification = null;
            }
          }
        }
      }

      const canvas = document.getElementById('game-canvas');
      new Game(canvas);

      console.log('ğŸŒŸ ã‚³ã‚¹ãƒ¢ãªã½ã‚ŠãŸã‚“ ã‚µãƒã‚¤ãƒãƒ¼ã‚¹ã‚¿ãƒ¼ã‚º ğŸ');
      console.log('WASDã¾ãŸã¯æ–¹å‘ã‚­ãƒ¼ã§ç§»å‹•ã—ã¦ã­ï¼');
    })();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>„Ç≥„Çπ„É¢„Å™„ÅΩ„Çä„Åü„Çì „Çµ„Éê„Ç§„Éê„Éº„Çπ„Çø„Éº„Ç∫ üåü</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', 'Hiragino Sans', 'Meiryo', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
      color: white;
      overflow: hidden;
    }

    #app {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }

    #game-container {
      position: relative;
      width: 800px;
      height: 600px;
      max-width: 100vw;
      max-height: 100vh;
      background: #000;
      border: 4px solid #4a90e2;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
    }

    @media (max-width: 820px) {
      #game-container {
        width: 100vw;
        height: calc(100vw * 0.75); /* 4:3„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÁ∂≠ÊåÅ */
        max-height: 100vh;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
    }

    @media (max-height: 620px) {
      #game-container {
        width: calc(100vh * 1.333); /* 4:3„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÁ∂≠ÊåÅ */
        height: 100vh;
        max-width: 100vw;
        border-radius: 0;
        border-top: none;
        border-bottom: none;
      }
    }

    @media (max-width: 820px) and (max-height: 620px) {
      #game-container {
        width: calc(100vh * 1.333);
        height: 100vh;
      }
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }

    @media (max-width: 600px) {
      #hud {
        padding: 10px;
        min-width: 150px;
        top: 5px;
        left: 5px;
      }

      .hud-item {
        font-size: 12px !important;
      }

      .hp-bar, .xp-bar {
        height: 16px !important;
      }
    }

    #buffs {
      position: absolute;
      bottom: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    @media (max-width: 600px) {
      #buffs {
        bottom: 5px;
        left: 5px;
      }

      .buff-item {
        padding: 6px 10px !important;
        min-width: 120px !important;
      }

      .buff-icon {
        font-size: 16px !important;
      }

      .buff-name {
        font-size: 10px !important;
      }
    }

    .buff-item {
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 150px;
      border: 2px solid;
    }

    .buff-icon {
      font-size: 20px;
    }

    .buff-info {
      flex: 1;
    }

    .buff-name {
      font-size: 12px;
      font-weight: bold;
    }

    .buff-timer {
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }

    .buff-timer-fill {
      height: 100%;
      background: white;
      transition: width 0.1s linear;
    }

    #pause-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #4a90e2;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      transition: all 0.3s;
    }

    @media (max-width: 600px) {
      #pause-btn {
        width: 40px;
        height: 40px;
        top: 5px;
        right: 5px;
      }

      #pause-btn .pause-icon {
        width: 16px !important;
        height: 20px !important;
      }

      #pause-btn .pause-icon::before,
      #pause-btn .pause-icon::after {
        width: 5px !important;
        height: 20px !important;
      }

      #pause-btn.paused .pause-icon::before {
        border-width: 10px 0 10px 16px !important;
        left: 4px !important;
      }
    }

    #pause-btn:hover {
      background: rgba(74, 144, 226, 0.3);
      transform: scale(1.1);
    }

    #pause-btn .pause-icon {
      width: 20px;
      height: 24px;
      position: relative;
    }

    #pause-btn .pause-icon::before,
    #pause-btn .pause-icon::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 24px;
      background: white;
      border-radius: 2px;
    }

    #pause-btn .pause-icon::before {
      left: 0;
    }

    #pause-btn .pause-icon::after {
      right: 0;
    }

    #pause-btn.paused .pause-icon::before {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 12px 0 12px 20px;
      border-color: transparent transparent transparent white;
      background: transparent;
      left: 5px;
      top: 0;
    }

    #pause-btn.paused .pause-icon::after {
      display: none;
    }

    .hud-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .hp-bar, .xp-bar {
      flex: 1;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ee5a6f);
      transition: width 0.3s ease;
      width: 100%;
    }

    .xp-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #44a08d);
      transition: width 0.3s ease;
      width: 0%;
    }

    .modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: all;
      z-index: 100;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 500px;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
    }

    @media (max-width: 600px) {
      .modal-content {
        max-width: 90vw;
        padding: 20px;
      }

      .modal-content h1 {
        font-size: 28px !important;
      }

      .modal-content h2 {
        font-size: 22px !important;
      }

      .modal-content p {
        font-size: 14px !important;
      }

      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }

      .btn-large {
        padding: 12px 32px;
        font-size: 16px;
      }
    }

    .modal-content h1 {
      font-size: 36px;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .modal-content h2 {
      font-size: 28px;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .modal-content p {
      font-size: 16px;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      pointer-events: all;
      box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-large {
      padding: 16px 48px;
      font-size: 20px;
    }

    .upgrade-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .upgrade-card {
      background: rgba(255, 255, 255, 0.15);
      padding: 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
      backdrop-filter: blur(10px);
    }

    .upgrade-card:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-4px);
    }

    .upgrade-card h3 {
      font-size: 20px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upgrade-card p {
      font-size: 14px;
      margin: 0;
      opacity: 0.9;
    }

    /* „Éù„Éº„Ç∫„É°„Éã„É•„ÉºÁî®„ÅÆ„Çπ„Çø„Ç§„É´ */
    .sound-setting {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 12px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sound-setting label {
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle-switch.active {
      background: #4caf50;
    }

    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(30px);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .btn-danger:hover {
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
    }

    .btn-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    .btn-selected {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      
      <div id="ui-overlay">
        <div id="hud">
          <div class="hud-item">
            <span>‚ù§Ô∏è HP:</span>
            <div class="hp-bar">
              <div id="hp-fill" class="hp-fill"></div>
            </div>
            <span id="hp-text">100/100</span>
          </div>
          <div class="hud-item">
            <span>‚≠ê XP:</span>
            <div class="xp-bar">
              <div id="xp-fill" class="xp-fill"></div>
            </div>
            <span id="xp-text">0/10</span>
          </div>
          <div class="hud-item">
            <span>üéØ „É¨„Éô„É´:</span>
            <span id="level-text">1</span>
          </div>
          <div class="hud-item">
            <span>‚è±Ô∏è ÊôÇÈñì:</span>
            <span id="time-text">0:00</span>
          </div>
        </div>

        <div id="buffs"></div>

        <button id="pause-btn" aria-label="„Éù„Éº„Ç∫">
          <div class="pause-icon"></div>
        </button>

        <div id="start-modal" class="modal">
          <div class="modal-content">
            <h1>üåü „Ç≥„Çπ„É¢„Å™„ÅΩ„Çä„Åü„Çì üçù</h1>
            <h2>„Çµ„Éê„Ç§„Éê„Éº„Çπ„Çø„Éº„Ç∫</h2>
            <p>
              WASD„Åæ„Åü„ÅØÊñπÂêë„Ç≠„Éº„ÅßÁßªÂãï„Åó„Çà„ÅÜÔºÅ<br>
              „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ„Åß„ÇÇÁßªÂãï„Åß„Åç„Çã„ÇàÔºÅüñ±Ô∏è<br>
              „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åó„Å¶Âº∑„Åè„Å™„Çä„ÄÅ<br>
              „Éú„Çπ„Çí„Åü„Åä„Åù„ÅÜ!
            </p>
            <div id="music-selection" style="margin-bottom: 20px;">
              <p style="font-size: 18px; margin-bottom: 10px; font-weight: bold;">Èü≥Ê•ΩË®≠ÂÆö</p>
              <button id="music-on-btn" class="btn" style="margin-right: 10px;">üîä Èü≥Ê•Ω„ÅÇ„Çä</button>
              <button id="music-off-btn" class="btn">üîá Èü≥Ê•Ω„Å™„Åó</button>
            </div>
            <button id="start-btn" class="btn btn-large" style="display: none;">„Ç≤„Éº„É†„Çπ„Çø„Éº„Éà üöÄ</button>
          </div>
        </div>

        <div id="levelup-modal" class="modal hidden">
          <div class="modal-content">
            <h2>üéâ „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ</h2>
            <p>Âº∑Âåñ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</p>
            <div id="upgrade-options" class="upgrade-options"></div>
          </div>
        </div>

        <div id="pause-modal" class="modal hidden">
          <div class="modal-content">
            <h2>‚è∏Ô∏è „Éù„Éº„Ç∫„É°„Éã„É•„Éº</h2>
            
            <div class="sound-setting">
              <label>
                <span>üéµ</span>
                <span>BGM</span>
              </label>
              <div class="toggle-switch active" id="bgm-toggle">
                <div class="toggle-slider"></div>
              </div>
            </div>

            <div class="sound-setting">
              <label>
                <span>üîä</span>
                <span>ÂäπÊûúÈü≥</span>
              </label>
              <div class="toggle-switch active" id="sfx-toggle">
                <div class="toggle-slider"></div>
              </div>
            </div>

            <div class="btn-group">
              <button class="btn btn-large" id="resume-btn">‚ñ∂Ô∏è „Ç≤„Éº„É†„Å´Êàª„Çã</button>
              <button class="btn btn-large btn-danger" id="quit-btn">üö™ „Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü</button>
            </div>
          </div>
        </div>

        <div id="gameover-modal" class="modal hidden">
          <div class="modal-content">
            <h2>üí´ „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h2>
            <div id="final-stats" style="margin: 20px 0; font-size: 18px; line-height: 1.8;"></div>
            <button id="restart-btn" class="btn btn-large">„Çπ„Çø„Éº„ÉàÁîªÈù¢„Å´Êàª„Çã</button>
          </div>
        </div>

        <!-- „Ç≤„Éº„É†„ÇØ„É™„Ç¢„É¢„Éº„ÉÄ„É´ -->
        <div id="gameclear-modal" class="modal hidden">
          <div class="modal-content" style="max-width: 600px;">
            <h2 style="color: #ffd700; font-size: 2.5em; text-shadow: 0 0 20px #ffd700;">üéâ „Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ üéâ</h2>
            <p style="font-size: 1.3em; margin: 20px 0;">ÊúÄÁµÇ„Éú„Çπ„ÇíÊíÉÁ†¥ÔºÅ„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ</p>
            <div id="clear-stats" style="margin: 20px 0; font-size: 18px; line-height: 1.8;"></div>
            <div style="margin: 30px 0;">
              <img src="kancho.png" alt="„Ç≥„Çπ„É¢„Éõ„Éº„É´È§®Èï∑" style="max-width: 35%; height: auto; border-radius: 10px; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
            </div>
            <button id="restart-clear-btn" class="btn btn-large" style="background: linear-gradient(135deg, #ffd700, #ffed4e); color: #000; font-weight: bold;">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // Êïµ„ÅÆ„Çø„Ç§„ÉóÂÆöÁæ©
      const ENEMY_TYPES = {
        BASIC: {
          name: 'Âü∫Êú¨Êïµ',
          emoji: 'üëæ',
          color: '#ff6b6b',
          secondaryColor: '#e74c3c',
          hp: 22,
          speed: 0.8,
          damage: 5,
          xp: 5,
          spawnWeight: 50,
          minLevel: 1,
        },
        FAST: {
          name: 'ÈÄü„ÅÑÊïµ',
          emoji: '‚ö°',
          color: '#feca57',
          secondaryColor: '#f39c12',
          hp: 12,
          speed: 1.5,
          damage: 4,
          xp: 8,
          spawnWeight: 30,
          minLevel: 3,
        },
        SHOOTER: {
          name: '„Ç∑„É•„Éº„Çø„Éº',
          emoji: 'üåÄ',
          color: '#f39c12',
          secondaryColor: '#e67e22',
          hp: 18,
          speed: 0.7,
          damage: 5,
          xp: 15,
          spawnWeight: 25,
          shootInterval: 2500,
          minLevel: 6,
        },
        TANK: {
          name: '„Çø„É≥„ÇØ',
          emoji: 'üõ°Ô∏è',
          color: '#9b59b6',
          secondaryColor: '#8e44ad',
          hp: 60,
          speed: 0.35,
          damage: 10,
          xp: 25,
          spawnWeight: 20,
          minLevel: 11,
        },
        CHARGER: {
          name: '„ÉÅ„É£„Éº„Ç∏„É£„Éº',
          emoji: 'üí®',
          color: '#e74c3c',
          secondaryColor: '#c0392b',
          hp: 25,
          speed: 0.5,
          damage: 15,
          xp: 20,
          spawnWeight: 15,
          chargeInterval: 3500,
          chargeSpeed: 3.5,
          chargeDuration: 800,
          minLevel: 13,
        },
        DEBUFFER: {
          name: '„Éá„Éê„ÉïÊïµ',
          emoji: 'üíÄ',
          color: '#9b59b6',
          secondaryColor: '#8e44ad',
          hp: 18,
          speed: 0.7,
          damage: 5,
          xp: 18,
          spawnWeight: 15,
          debuffRange: 100,
          minLevel: 15,
        },
        SPLITTER: {
          name: '„Çπ„Éó„É™„ÉÉ„Çø„Éº',
          emoji: 'üîÑ',
          color: '#2ecc71',
          secondaryColor: '#27ae60',
          hp: 30,
          speed: 0.6,
          damage: 8,
          xp: 22,
          spawnWeight: 10,
          splitCount: 2,
          minLevel: 18,
        },
        MINIBOSS: {
          name: '‰∏≠„Éú„Çπ',
          emoji: 'üëë',
          color: '#8b00ff',
          secondaryColor: '#6a00cc',
          hp: 250,
          speed: 0.5,
          damage: 15,
          xp: 50,
          spawnWeight: 0,
          shootInterval: 1800,
          minLevel: 1,
        },
        FINALBOSS: {
          name: 'ÊúÄÁµÇ„Éú„Çπ',
          emoji: 'üî•',
          color: '#ff0000',
          secondaryColor: '#cc0000',
          hp: 800,
          speed: 0.6,
          damage: 20,
          xp: 200,
          spawnWeight: 0,
          shootInterval: 1000,
          minLevel: 20,
        }
      };

      function drawPlayer(ctx, player, img, time) {
        ctx.save();
        
        // ÁÑ°ÊïµÊôÇ„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà
        const isInvincible = player.invincibleUntil && time < player.invincibleUntil;
        
        if (isInvincible) {
          // ËôπËâ≤„ÅÆ„Ç™„Éº„É©
          const hue = (time / 10) % 360;
          ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
          ctx.shadowBlur = 30;
          
          // ÂõûËª¢„Åô„ÇãËôπËâ≤„ÅÆËº™
          const rotationSpeed = time / 500;
          for (let i = 0; i < 3; i++) {
            const angle = rotationSpeed + (i * Math.PI * 2 / 3);
            const radius = player.radius + 15 + Math.sin(time / 200 + i) * 5;
            
            ctx.strokeStyle = `hsl(${(hue + i * 120) % 360}, 100%, 60%)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.position.x, player.position.y, radius, angle, angle + Math.PI);
            ctx.stroke();
          }
          
          // „Ç≠„É©„Ç≠„É©Êòü
          for (let i = 0; i < 6; i++) {
            const starAngle = rotationSpeed * 2 + (i * Math.PI / 3);
            const starDist = player.radius + 20;
            const starX = player.position.x + Math.cos(starAngle) * starDist;
            const starY = player.position.y + Math.sin(starAngle) * starDist;
            const starHue = (hue + i * 60) % 360;
            
            ctx.fillStyle = `hsl(${starHue}, 100%, 80%)`;
            ctx.shadowColor = `hsl(${starHue}, 100%, 70%)`;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(starX, starY, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÁõ¥Âæå„ÅØËµ§„ÅèÈÄèÊòéÁÇπÊªÖ
        const timeSinceDamage = time - player.lastDamageTime;
        if (timeSinceDamage < player.damageCooldown && !isInvincible) {
          const flashInterval = 100;
          if (Math.floor(timeSinceDamage / flashInterval) % 2 === 1) {
            ctx.globalAlpha = 0.5;
          }
          // Ëµ§„ÅÑ„ÉÜ„Ç£„É≥„Éà
          ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
          ctx.globalCompositeOperation = 'source-atop';
        }
        
        if (player.shield > 0) {
          const shimmer = Math.sin(time / 200) * 0.3 + 0.7;
          ctx.shadowColor = `rgba(72, 219, 251, ${shimmer})`;
          ctx.shadowBlur = 20;
          ctx.strokeStyle = `rgba(72, 219, 251, ${shimmer})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(player.position.x, player.position.y, player.radius + 10, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        if (img && img.complete) {
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          ctx.globalCompositeOperation = 'source-over';
          
          // ÁîªÂÉè„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„Çí‰øùÊåÅ„Åó„Å¶ÊèèÁîª
          const imgAspect = img.width / img.height;
          let drawWidth = player.radius * 2.5;
          let drawHeight = player.radius * 2.5;
          
          if (imgAspect > 1) {
            // Ê®™Èï∑„ÅÆÁîªÂÉè
            drawHeight = drawWidth / imgAspect;
          } else if (imgAspect < 1) {
            // Á∏¶Èï∑„ÅÆÁîªÂÉè
            drawWidth = drawHeight * imgAspect;
          }
          
          ctx.drawImage(
            img,
            player.position.x - drawWidth / 2,
            player.position.y - drawHeight / 2,
            drawWidth,
            drawHeight
          );
          
          // „ÉÄ„É°„Éº„Ç∏ÊôÇ„ÅÆËµ§„ÅÑ„Ç™„Éº„Éê„Éº„É¨„Ç§ÔºàÁÑ°ÊïµÊôÇ‰ª•Â§ñÔºâ
          if (timeSinceDamage < player.damageCooldown && !isInvincible) {
            const flashInterval = 100;
            if (Math.floor(timeSinceDamage / flashInterval) % 2 === 1) {
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
              ctx.beginPath();
              ctx.arc(player.position.x, player.position.y, player.radius * 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else {
          ctx.beginPath();
          ctx.arc(player.position.x, player.position.y, player.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ffd700';
          ctx.fill();
          ctx.strokeStyle = '#ffed4e';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawEnemy(ctx, enemy, reducedEffects = false) {
        ctx.save();
        
        const type = enemy.type;
        const time = performance.now();
        
        // „ÉÄ„É°„Éº„Ç∏„Éï„É©„ÉÉ„Ç∑„É•
        if (enemy.damageFlash > 0) {
          ctx.globalAlpha = 0.5 + (enemy.damageFlash / 200);
        }

        // „Çø„Ç§„Éó„Åî„Å®„Å´Áï∞„Å™„ÇãÊèèÁîª
        switch(type.name) {
          case 'Âü∫Êú¨Êïµ':
            // „Ç∑„É≥„Éó„É´„Å™Ëµ§„ÅÑÂÜÜ
            ctx.beginPath();
            ctx.arc(enemy.position.x, enemy.position.y, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
            
          case 'ÈÄü„ÅÑÊïµ':
            // ÊµÅÁ∑öÂûã„ÅÆÈùí„ÅÑÂΩ¢„ÄÅ„É¢„Éê„Ç§„É´„ÅØÂ∞æ„ÇíÁ∞°Áï•Âåñ
            ctx.translate(enemy.position.x, enemy.position.y);
            const angle = Math.atan2(enemy.velocity.y, enemy.velocity.x);
            ctx.rotate(angle);
            
            // Êú¨‰ΩìÔºàÊµÅÁ∑öÂûãÔºâ
            ctx.beginPath();
            ctx.ellipse(0, 0, enemy.radius * 1.2, enemy.radius * 0.7, 0, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Â∞æÔºà„É¢„Éê„Ç§„É´„Åß„ÅØÁ∞°Áï•ÂåñÔºâ
            if (!reducedEffects) {
              const tailLength = enemy.radius * 1.5;
              for (let i = 0; i < 3; i++) {
                const alpha = 0.3 - i * 0.1;
                ctx.strokeStyle = `rgba(52, 152, 219, ${alpha})`;
                ctx.lineWidth = enemy.radius * 0.4 - i * 2;
                ctx.beginPath();
                ctx.moveTo(-enemy.radius, 0);
                ctx.lineTo(-enemy.radius - tailLength + i * 5, 0);
                ctx.stroke();
              }
            }
            break;
            
          case '„Çø„É≥„ÇØ':
            // Á¥´„ÅÆÂÖ≠ËßíÂΩ¢Ôºà„É¢„Éê„Ç§„É´„Åß„ÅØÂõûËª¢„ÇíÁ∞°Áï•ÂåñÔºâ
            ctx.translate(enemy.position.x, enemy.position.y);
            if (!reducedEffects) {
              ctx.rotate(time / 2000); // PC„ÅÆ„Åø„ÇÜ„Å£„Åè„ÇäÂõûËª¢
            }
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Ë£ÖÁî≤„É©„Ç§„É≥Ôºà„É¢„Éê„Ç§„É´„Åß„ÅØÁúÅÁï•Ôºâ
            if (!reducedEffects) {
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
              ctx.lineWidth = 2;
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = Math.cos(angle) * enemy.radius * 0.5;
                const y = Math.sin(angle) * enemy.radius * 0.5;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            break;
            
          case '„Ç∑„É•„Éº„Çø„Éº':
            // „Ç™„É¨„É≥„Ç∏„ÅÆÂÜÜ+Á†≤Ë∫´
            ctx.translate(enemy.position.x, enemy.position.y);
            const shooterAngle = Math.atan2(
              enemy.targetY - enemy.position.y,
              enemy.targetX - enemy.position.x
            );
            ctx.rotate(shooterAngle);
            
            // Êú¨‰Ωì
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Á†≤Ë∫´
            ctx.fillStyle = type.secondaryColor;
            ctx.fillRect(0, -enemy.radius * 0.3, enemy.radius * 0.8, enemy.radius * 0.6);
            
            // ÁÖßÊ∫ñ„Éû„Éº„ÇØÔºà„É¢„Éê„Ç§„É´„Åß„ÅØÁúÅÁï•Ôºâ
            if (!reducedEffects) {
              ctx.strokeStyle = '#ff0000';
              ctx.lineWidth = 1;
              const crosshairSize = 5;
              ctx.beginPath();
              ctx.moveTo(enemy.radius * 0.8 + 5 - crosshairSize, 0);
              ctx.lineTo(enemy.radius * 0.8 + 5 + crosshairSize, 0);
              ctx.moveTo(enemy.radius * 0.8 + 5, -crosshairSize);
              ctx.lineTo(enemy.radius * 0.8 + 5, crosshairSize);
              ctx.stroke();
            }
            break;
            
          case '„ÉÅ„É£„Éº„Ç∏„É£„Éº':
            // Ëµ§„ÅÑ„Éà„Ç≤„Éà„Ç≤Ôºà„É¢„Éê„Ç§„É´„Åß„ÅØ„Ç∑„É£„Éâ„Ç¶„ÇíÁ∞°Áï•ÂåñÔºâ
            ctx.translate(enemy.position.x, enemy.position.y);
            
            const isCharging = enemy.chargeState === 'charging';
            const isPrepping = enemy.chargeState === 'preparing';
            
            // Á™ÅÈÄ≤Ê∫ñÂÇô‰∏≠„ÅØÁÇπÊªÖ
            if (isPrepping) {
              const flash = Math.sin(time / 100) * 0.5 + 0.5;
              ctx.globalAlpha = 0.5 + flash * 0.5;
            }
            
            // „Éà„Ç≤„Éà„Ç≤„ÅÆÂÜÜ
            const spikes = 8;
            ctx.beginPath();
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (Math.PI / spikes) * i;
              const radius = i % 2 === 0 ? enemy.radius * 1.3 : enemy.radius * 0.7;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // Á™ÅÈÄ≤‰∏≠„ÅØÁôΩ„ÅèÂÖâ„Çã
            if (isCharging) {
              ctx.fillStyle = '#ffffff';
              if (!reducedEffects) {
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 20;
              }
            } else {
              ctx.fillStyle = type.color;
            }
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
            
          case '„Éá„Éê„ÉïÊïµ':
            // Á¥´„ÅÆÂÜÜÔºà„É¢„Éê„Ç§„É´„Åß„ÅØÊ≥¢Á¥ã„ÇíÁ∞°Áï•ÂåñÔºâ
            ctx.translate(enemy.position.x, enemy.position.y);
            
            // Ê≥¢Á¥ã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ôºà„É¢„Éê„Ç§„É´„Åß„ÅØ1„Å§„Å†„ÅëÔºâ
            const rippleTime = (time / 1000) % 1;
            const rippleCount = reducedEffects ? 1 : 3;
            for (let i = 0; i < rippleCount; i++) {
              const rippleRadius = enemy.radius + (rippleTime + i * 0.33) * type.debuffRange;
              const rippleAlpha = Math.max(0, 0.3 - (rippleTime + i * 0.33) * 0.3);
              
              ctx.strokeStyle = `rgba(155, 89, 182, ${rippleAlpha})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Êú¨‰Ωì
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // „Éâ„ÇØ„É≠„Éû„Éº„ÇØÈ¢®Ôºà„É¢„Éê„Ç§„É´„Åß„ÅØÁúÅÁï•Ôºâ
            if (!reducedEffects) {
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.arc(-enemy.radius * 0.3, -enemy.radius * 0.2, enemy.radius * 0.2, 0, Math.PI * 2);
              ctx.arc(enemy.radius * 0.3, -enemy.radius * 0.2, enemy.radius * 0.2, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
            
          case '„Çπ„Éó„É™„ÉÉ„Çø„Éº':
            // Á∑ë„ÅÆÁ¥∞ËÉûÂûã+‰∏≠ÂøÉ„Å´Ê†∏+ÂàÜË£ÇÁ∑ö
            ctx.translate(enemy.position.x, enemy.position.y);
            
            // Á¥∞ËÉûËÜúÔºà„Å∑„Çà„Å∑„ÇàÔºâ
            const wobble = Math.sin(time / 200) * 0.1 + 1;
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
              const angle = (Math.PI * 2 / 16) * i;
              const radiusVar = enemy.radius * wobble * (0.9 + Math.sin(angle * 3 + time / 300) * 0.1);
              const x = Math.cos(angle) * radiusVar;
              const y = Math.sin(angle) * radiusVar;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ‰∏≠ÂøÉ„ÅÆÊ†∏
            ctx.fillStyle = type.secondaryColor;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // ÂàÜË£ÇÁ∑ö
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-enemy.radius, 0);
            ctx.lineTo(enemy.radius, 0);
            ctx.moveTo(0, -enemy.radius);
            ctx.lineTo(0, enemy.radius);
            ctx.stroke();
            break;
            
          case '‰∏≠„Éú„Çπ':
            // ÂõûËª¢„Åô„Çã‰∫îËßíÂΩ¢+„Ç™„Éº„É©
            ctx.translate(enemy.position.x, enemy.position.y);
            const bossRotation = time / 1000;
            ctx.rotate(bossRotation);
            
            // „Ç™„Éº„É©
            ctx.shadowColor = type.color;
            ctx.shadowBlur = 20;
            ctx.strokeStyle = type.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius + 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Êú¨‰ΩìÔºà‰∫îËßíÂΩ¢Ôºâ
            ctx.shadowBlur = 0;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ÁéãÂÜ†„Éû„Éº„ÇØ
            ctx.fillStyle = '#ffd700';
            ctx.font = `${enemy.radius}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üëë', 0, 0);
            break;
            
          case 'ÊúÄÁµÇ„Éú„Çπ':
            // Â∑®Â§ß„ÅßÂ®ÅÂúßÊÑü„ÅÆ„ÅÇ„ÇãÊúÄÁµÇ„Éú„Çπ
            ctx.translate(enemy.position.x, enemy.position.y);
            const finalBossRotation = time / 800;
            ctx.rotate(finalBossRotation);
            
            // Â§öÈáç„Ç™„Éº„É©„Ç®„Éï„Çß„ÇØ„Éà
            for (let i = 0; i < 3; i++) {
              const auraRadius = enemy.radius + 12 + i * 8;
              const auraAlpha = 0.3 - i * 0.1;
              ctx.strokeStyle = `rgba(255, 0, 0, ${auraAlpha})`;
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // ÁÇé„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;
            
            // Êú¨‰ΩìÔºàÂÖ´ËßíÂΩ¢Ôºâ
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 / 8) * i - Math.PI / 2;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.radius);
            gradient.addColorStop(0, '#ff6600');
            gradient.addColorStop(0.5, '#ff0000');
            gradient.addColorStop(1, '#cc0000');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // ÁÇé„Éû„Éº„ÇØ
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffff00';
            ctx.font = `${enemy.radius * 1.2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üî•', 0, 0);
            
            // Âë®Âõ≤„Å´ÂõûËª¢„Åô„ÇãÁÇé
            for (let i = 0; i < 6; i++) {
              const flameAngle = finalBossRotation * 2 + (i * Math.PI / 3);
              const flameDist = enemy.radius + 15;
              const flameX = Math.cos(flameAngle) * flameDist;
              const flameY = Math.sin(flameAngle) * flameDist;
              
              ctx.font = '16px Arial';
              ctx.fillText('üî•', flameX, flameY);
            }
            break;
        }

        ctx.restore();
        
        // HP„Éê„ÉºÔºà„Çø„É≥„ÇØ„ÄÅ‰∏≠„Éú„Çπ„ÄÅ„Çπ„Éó„É™„ÉÉ„Çø„Éº„ÄÅÊúÄÁµÇ„Éú„Çπ„ÅÆ„ÅøÔºâ
        if (type.name === '„Çø„É≥„ÇØ' || type.name === '‰∏≠„Éú„Çπ' || type.name === '„Çπ„Éó„É™„ÉÉ„Çø„Éº' || type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
          ctx.save();
          const barWidth = enemy.radius * 2;
          const barHeight = type.name === 'ÊúÄÁµÇ„Éú„Çπ' ? 6 : 4;
          const barX = enemy.position.x - enemy.radius;
          const barY = enemy.position.y - enemy.radius - (type.name === 'ÊúÄÁµÇ„Éú„Çπ' ? 15 : 10);
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          const hpPercent = enemy.hp / enemy.maxHp;
          ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
          ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
          ctx.restore();
        }
      }

      function drawItem(ctx, item) {
        ctx.save();
        
        const pulse = Math.sin(performance.now() / 200) * 0.2 + 1;
        const radius = item.radius * pulse;
        
        ctx.shadowColor = item.color;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(item.position.x, item.position.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = item.color;
        ctx.fill();
        
        ctx.font = `${radius * 1.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.emoji, item.position.x, item.position.y);
        
        ctx.restore();
      }

      function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      // „Éó„É¨„Ç§„É§„Éº„ÅÆ„É¨„Éô„É´„Å´Âøú„Åò„Å¶Âá∫ÁèæÂèØËÉΩ„Å™Êïµ„Çø„Ç§„Éó„ÇíÈÅ∏ÊäûÔºàÈáç„Åø‰ªò„ÅçÔºâ
      function getRandomEnemyType(playerLevel) {
        const availableTypes = Object.values(ENEMY_TYPES).filter(t => 
          t.spawnWeight > 0 && t.minLevel <= playerLevel
        );
        
        if (availableTypes.length === 0) {
          return ENEMY_TYPES.BASIC;
        }
        
        const totalWeight = availableTypes.reduce((sum, t) => sum + t.spawnWeight, 0);
        let random = Math.random() * totalWeight;
        
        for (const type of availableTypes) {
          random -= type.spawnWeight;
          if (random <= 0) {
            return type;
          }
        }
        
        return availableTypes[0];
      }

      class Game {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          
          // „É¢„Éê„Ç§„É´Âà§ÂÆö
          this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
          
          // „Éá„Éê„Ç§„Çπ„Å´Âøú„Åò„ÅüË®≠ÂÆö
          this.maxEnemies = this.isMobile ? 10 : 30; // „É¢„Éê„Ç§„É´„ÅØÊïµ„Çí10‰Ωì„Åæ„Åß
          this.reducedEffects = this.isMobile; // „É¢„Éê„Ç§„É´„ÅØ„Ç®„Éï„Çß„ÇØ„Éà„ÇíÂâäÊ∏õ
          this.collisionCheckFrame = 0; // ÂΩì„Åü„ÇäÂà§ÂÆö„ÇíÈñìÂºï„Åè„Åü„ÇÅ„ÅÆ„Ç´„Ç¶„É≥„Çø„Éº
          this.isRunning = false;
          this.isPaused = false;
          this.isGameOver = false;
          this.lastTime = 0;
          this.gameTime = 0;

          this.playerImage = new Image();
          this.playerImage.src = 'images/cosmo-napolitan.png';

          this.player = {
            position: { x: canvas.width / 2, y: canvas.height / 2 },
            velocity: { x: 0, y: 0 },
            radius: 16,
            speed: 150,
            hp: 100,
            maxHp: 100,
            xp: 0,
            xpToNextLevel: 10,
            level: 1,
            damage: 15,
            attackSpeed: 1.0,
            projectileSpeed: 300,
            projectileSize: 1.0,
            piercing: 0,
            range: 250,
            shield: 0,
            lastDamageTime: 0, // ÊúÄÂæå„Å´„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÊôÇÂàª
            damageCooldown: 500, // „ÉÄ„É°„Éº„Ç∏„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Ôºà„Éü„É™ÁßíÔºâ
            projectileCount: 1, // ÂêåÊôÇ„Å´Áô∫Â∞Ñ„Åô„ÇãÂºæÊï∞
            invincibleUntil: 0, // ÁÑ°ÊïµÊôÇÈñì„ÅÆÁµÇ‰∫ÜÊôÇÂàª
          };

          this.keys = {};
          this.mouseTarget = null; // „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅÆÁõÆÊ®ôÂú∞ÁÇπ
          this.enemies = [];
          this.projectiles = [];
          this.enemyProjectiles = [];
          this.xpOrbs = [];
          this.items = [];

          this.lastShootTime = 0;
          this.lastEnemySpawnTime = 0;
          this.enemySpawnInterval = 1500;
          this.lastBossLevel = 0; // ÊúÄÂæå„Å´„Éú„Çπ„ÇíÂá∫Áèæ„Åï„Åõ„Åü„É¨„Éô„É´
          this.finalBossSpawned = false; // ÊúÄÁµÇ„Éú„Çπ„ÅåÂá∫Áèæ„Åó„Åü„Åã

          this.stats = {
            enemiesKilled: 0,
            damageDealt: 0,
            timeAlive: 0,
            level: 1,
          };

          // BGMË®≠ÂÆö
          this.currentBGM = null;
          
          // „Çµ„Ç¶„É≥„ÉâË®≠ÂÆö
          this.bgmEnabled = true;
          this.sfxEnabled = true;

          // BGM„ÅÆ„Éë„Çπ„Çí‰øùÂ≠òÔºàÈÅÖÂª∂Ë™≠„ÅøËæº„ÅøÁî®Ôºâ
          this.bgmSources = {
            title: 'audio/title_bgm.mp3',
            normal: 'audio/normal_bgm.mp3',
            miniboss: 'audio/miniboss_bgm.mp3',
            finalboss: 'audio/finalboss_bgm.mp3',
            clear: 'audio/clear_bgm.mp3',
            gameover: 'audio/gameover_bgm.mp3'
          };
          
          // BGM„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÔºàÂÆüÈöõ„ÅÆË™≠„ÅøËæº„Åø„ÅØÂæå„ÅßË°å„ÅÜÔºâ
          this.bgm = {
            title: null,
            normal: null,
            miniboss: null,
            finalboss: null,
            clear: null,
            gameover: null,
            current: null
          };
          
          // BGM„Åå„É≠„Éº„ÉâÊ∏à„Åø„Åã„Å©„ÅÜ„Åã„ÅÆ„Éï„É©„Ç∞
          this.bgmLoaded = {};

          // ÂäπÊûúÈü≥„ÅÆÂàùÊúüÂåñ
          this.sfx = {
            playerHit: new Audio('audio/player_damage.mp3'),
            enemyHit: new Audio('audio/enemy_hit.mp3'),
            enemyDeath: new Audio('audio/enemy_death.mp3'),
            bossDeath: new Audio('audio/boss_death.mp3'),
            gemGet: new Audio('audio/gem_get.mp3'),
            itemGet: new Audio('audio/item_get.mp3')
          };
          
          // ÂäπÊûúÈü≥„ÅÆÈü≥ÈáèË®≠ÂÆö
          this.sfx.playerHit.volume = 0.6;
          this.sfx.enemyHit.volume = 0.15;
          this.sfx.enemyDeath.volume = 0.5;
          this.sfx.bossDeath.volume = 0.7;
          this.sfx.gemGet.volume = 0.5;
          this.sfx.itemGet.volume = 0.6;

          this.activeEffects = {
            speedBoost: 0,
            powerUp: 0,
            timeSlow: 0,
            invincible: 0,
            magnet: 0,
          };

          this.itemNotification = null;
          this.itemNotificationTime = 0;

          this.setupUI();
          this.setupEventListeners();
        }

        setupUI() {
          this.hpFill = document.getElementById('hp-fill');
          this.hpText = document.getElementById('hp-text');
          this.xpFill = document.getElementById('xp-fill');
          this.xpText = document.getElementById('xp-text');
          this.levelText = document.getElementById('level-text');
          this.timeText = document.getElementById('time-text');
          this.buffsFill = document.getElementById('buffs');
          
          this.startModal = document.getElementById('start-modal');
          this.levelupModal = document.getElementById('levelup-modal');
          this.pauseModal = document.getElementById('pause-modal');
          this.gameoverModal = document.getElementById('gameover-modal');
          this.gameclearModal = document.getElementById('gameclear-modal');
          this.upgradeOptions = document.getElementById('upgrade-options');
          this.buffsContainer = document.getElementById('buffs');

          this.pauseBtn = document.getElementById('pause-btn');
        }

        setupEventListeners() {
          const musicOnBtn = document.getElementById('music-on-btn');
          const musicOffBtn = document.getElementById('music-off-btn');
          const startBtn = document.getElementById('start-btn');

          // Èü≥Ê•Ω„ÅÇ„Çä„Éú„Çø„É≥
          musicOnBtn.addEventListener('click', () => {
            this.bgmEnabled = true;
            this.sfxEnabled = true; // ÂäπÊûúÈü≥„ÇÇON„Å´
            document.getElementById('bgm-toggle').classList.add('active');
            document.getElementById('sfx-toggle').classList.add('active'); // ÂäπÊûúÈü≥„Éà„Ç∞„É´„ÇÇON„Å´
            
            // „Éú„Çø„É≥„ÅÆ„Éè„Ç§„É©„Ç§„Éà
            musicOnBtn.classList.add('btn-selected');
            musicOffBtn.classList.remove('btn-selected');
            
            // „Çø„Ç§„Éà„É´BGM„ÇíÂÜçÁîü
            this.playBGM('title');
            
            // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíË°®Á§∫
            startBtn.style.display = 'inline-block';
          });

          // Èü≥Ê•Ω„Å™„Åó„Éú„Çø„É≥
          musicOffBtn.addEventListener('click', () => {
            this.bgmEnabled = false;
            this.sfxEnabled = false; // ÂäπÊûúÈü≥„ÇÇOFF„Å´
            document.getElementById('bgm-toggle').classList.remove('active');
            document.getElementById('sfx-toggle').classList.remove('active'); // ÂäπÊûúÈü≥„Éà„Ç∞„É´„ÇÇOFF„Å´
            
            // „Éú„Çø„É≥„ÅÆ„Éè„Ç§„É©„Ç§„Éà
            musicOffBtn.classList.add('btn-selected');
            musicOnBtn.classList.remove('btn-selected');
            
            // BGM„ÇíÂÅúÊ≠¢
            this.stopBGM();
            
            // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíË°®Á§∫
            startBtn.style.display = 'inline-block';
          });

          // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥
          startBtn.addEventListener('click', () => {
            this.stopBGM(); // „Çø„Ç§„Éà„É´BGM„ÇíÂÅúÊ≠¢
            this.startModal.classList.add('hidden');
            this.start();
          });

          document.getElementById('restart-btn').addEventListener('click', () => {
            window.location.reload();
          });

          document.getElementById('restart-clear-btn').addEventListener('click', () => {
            window.location.reload();
          });

          document.getElementById('resume-btn').addEventListener('click', () => {
            this.togglePause();
          });

          this.pauseBtn.addEventListener('click', () => {
            this.togglePause();
          });

          document.addEventListener('keydown', (e) => {
            this.keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'p' && this.isRunning && !this.isGameOver) {
              this.togglePause();
            }
          });

          document.addEventListener('keyup', (e) => {
            this.keys[e.key.toLowerCase()] = false;
          });

          // „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ„ÅßÁßªÂãï
          this.canvas.addEventListener('mousedown', (e) => {
            if (this.isPaused || this.isGameOver) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            this.mouseTarget = {
              x: (e.clientX - rect.left) * scaleX,
              y: (e.clientY - rect.top) * scaleY
            };
          });

          // „Éû„Ç¶„ÇπÁßªÂãï‰∏≠„ÇÇÁõÆÊ®ôÂú∞ÁÇπ„ÇíÊõ¥Êñ∞Ôºà„Éâ„É©„ÉÉ„Ç∞ÂØæÂøúÔºâ
          this.canvas.addEventListener('mousemove', (e) => {
            if (this.isPaused || this.isGameOver) return;
            if (e.buttons !== 1) return; // Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰∏≠„ÅÆ„Åø
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            this.mouseTarget = {
              x: (e.clientX - rect.left) * scaleX,
              y: (e.clientY - rect.top) * scaleY
            };
          });

          // „Éû„Ç¶„Çπ„ÇíÈõ¢„Åó„Åü„ÇâÁßªÂãïÂÅúÊ≠¢
          this.canvas.addEventListener('mouseup', () => {
            this.mouseTarget = null;
          });

          // „Çø„ÉÉ„ÉÅÊìç‰ΩúÂØæÂøú
          this.canvas.addEventListener('touchstart', (e) => {
            if (this.isPaused || this.isGameOver) return;
            e.preventDefault();
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            
            this.mouseTarget = {
              x: (touch.clientX - rect.left) * scaleX,
              y: (touch.clientY - rect.top) * scaleY
            };
          });

          this.canvas.addEventListener('touchmove', (e) => {
            if (this.isPaused || this.isGameOver) return;
            e.preventDefault();
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            
            this.mouseTarget = {
              x: (touch.clientX - rect.left) * scaleX,
              y: (touch.clientY - rect.top) * scaleY
            };
          });

          this.canvas.addEventListener('touchend', () => {
            this.mouseTarget = null;
          });


          // „Ç≤„Éº„É†ÁµÇ‰∫Ü„Éú„Çø„É≥
          document.getElementById('quit-btn').addEventListener('click', () => {
            if (confirm('Êú¨ÂΩì„Å´„Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü„Åó„Åæ„Åô„ÅãÔºü')) {
              this.quitGame();
            }
          });

          // BGM„Éà„Ç∞„É´
          document.getElementById('bgm-toggle').addEventListener('click', (e) => {
            this.bgmEnabled = !this.bgmEnabled;
            e.currentTarget.classList.toggle('active', this.bgmEnabled);
            
            if (this.bgmEnabled && !this.isPaused) {
              this.playBGM(this.currentBGM || 'normal');
            } else {
              this.stopBGM();
            }
          });

          // ÂäπÊûúÈü≥„Éà„Ç∞„É´
          document.getElementById('sfx-toggle').addEventListener('click', (e) => {
            this.sfxEnabled = !this.sfxEnabled;
            e.currentTarget.classList.toggle('active', this.sfxEnabled);
          });
        }

        start() {
          this.isRunning = true;
          this.lastTime = performance.now();
          this.gameLoop(this.lastTime);
          
          // ÈÄöÂ∏∏Êà¶ÈóòBGM„ÇíÂÜçÁîü
          this.playBGM('normal');
        }

        loadBGM(type) {
          // Êó¢„Å´„É≠„Éº„ÉâÊ∏à„Åø„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
          if (this.bgmLoaded[type]) {
            return Promise.resolve();
          }
          
          return new Promise((resolve, reject) => {
            const audio = new Audio(this.bgmSources[type]);
            
            // Èü≥Èáè„Å®„É´„Éº„ÉóË®≠ÂÆö
            const volumeSettings = {
              title: 0.5,
              normal: 0.5,
              miniboss: 0.6,
              finalboss: 0.7,
              clear: 0.6,
              gameover: 0.5
            };
            
            audio.volume = volumeSettings[type] || 0.5;
            audio.loop = true;
            
            // „É≠„Éº„ÉâÂÆå‰∫Ü„Ç§„Éô„É≥„Éà
            audio.addEventListener('canplaythrough', () => {
              this.bgm[type] = audio;
              this.bgmLoaded[type] = true;
              resolve();
            }, { once: true });
            
            // „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
            audio.addEventListener('error', (e) => {
              console.log(`BGM load failed (${type}):`, e);
              reject(e);
            });
            
            // „É≠„Éº„ÉâÈñãÂßã
            audio.load();
          });
        }

        playBGM(type) {
          // „Çµ„Ç¶„É≥„ÉâË®≠ÂÆö„ÅåOFF„ÅÆÂ†¥Âêà„ÅØÂÜçÁîü„Åó„Å™„ÅÑ
          if (!this.bgmEnabled) return;
          
          // ÁèæÂú®„ÅÆ„Çø„Ç§„Éó„Çí‰øùÂ≠ò
          this.currentBGM = type;
          
          // Âêå„ÅòBGM„ÅåÊó¢„Å´ÂÜçÁîü‰∏≠„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
          if (this.bgm.current === this.bgm[type] && this.bgm[type] && !this.bgm[type].paused) {
            return;
          }
          
          // ÁèæÂú®„ÅÆBGM„ÇíÂÅúÊ≠¢
          if (this.bgm.current && this.bgm.current !== this.bgm[type]) {
            this.bgm.current.pause();
            this.bgm.current.currentTime = 0;
          }
          
          // BGM„Çí„É≠„Éº„Éâ„Åó„Å¶ÂÜçÁîü
          this.loadBGM(type).then(() => {
            if (this.bgm[type] && this.currentBGM === type) {
              this.bgm.current = this.bgm[type];
              // „É¶„Éº„Ç∂„ÉºÊìç‰ΩúÂæå„Å™„ÅÆ„ÅßÂÜçÁîü„Åß„Åç„Çã„ÅØ„Åö
              this.bgm.current.play().catch(e => {
                console.log('BGM play failed:', e);
                // „É¢„Éê„Ç§„É´„ÅßËá™ÂãïÂÜçÁîü„Åå„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„ÅüÂ†¥Âêà„ÅÆÂØæÁ≠ñ
                // Ê¨°„ÅÆ„É¶„Éº„Ç∂„ÉºÊìç‰ΩúÊôÇ„Å´ÂÜçË©¶Ë°å
                document.addEventListener('touchstart', () => {
                  if (this.bgm.current && this.bgmEnabled) {
                    this.bgm.current.play().catch(() => {});
                  }
                }, { once: true });
              });
            }
          }).catch(e => {
            console.log('BGM load and play failed:', e);
          });
        }

        stopBGM() {
          if (this.bgm.current) {
            this.bgm.current.pause();
            this.bgm.current.currentTime = 0;
            this.bgm.current = null;
          }
        }

        playSFX(type) {
          // ÂäπÊûúÈü≥Ë®≠ÂÆö„ÅåOFF„ÅÆÂ†¥Âêà„ÅØÂÜçÁîü„Åó„Å™„ÅÑ
          if (!this.sfxEnabled) return;
          
          if (this.sfx[type]) {
            // Èü≥Â£∞„ÇíË§áË£Ω„Åó„Å¶ÂÜçÁîüÔºàÂêåÊôÇÂÜçÁîü„ÇíÂèØËÉΩ„Å´Ôºâ
            const sound = this.sfx[type].cloneNode();
            sound.volume = this.sfx[type].volume;
            sound.play().catch(e => console.log('SFX play failed:', e));
          }
        }

        togglePause() {
          if (this.isGameOver) return;
          
          this.isPaused = !this.isPaused;
          this.pauseModal.classList.toggle('hidden');
          this.pauseBtn.classList.toggle('paused');
          
          if (this.isPaused) {
            // „Éù„Éº„Ç∫ÊôÇ„ÅØBGM„Çí‰∏ÄÊôÇÂÅúÊ≠¢ÔºàstopBGM„ÅØ‰Ωø„Çè„Å™„ÅÑÔºâ
            if (this.bgm.current && this.bgmEnabled) {
              this.bgm.current.pause();
            }
          } else {
            // ÂÜçÈñãÊôÇ„ÅØBGM„ÇíÂÜçÁîü
            this.lastTime = performance.now();
            if (this.bgm.current && this.bgmEnabled) {
              this.bgm.current.play().catch(e => console.log('BGM resume failed:', e));
            }
            this.gameLoop(this.lastTime);
          }
        }

        quitGame() {
          this.isGameOver = true;
          this.stopBGM();
          this.pauseModal.classList.add('hidden');
          
          // „Çø„Ç§„Éà„É´ÁîªÈù¢„Å´Êàª„Çã
          window.location.reload();
        }

        gameLoop(currentTime) {
          if (!this.isRunning || this.isPaused) return;

          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;

          this.update(deltaTime, currentTime);
          this.render();

          if (!this.isGameOver) {
            requestAnimationFrame((time) => this.gameLoop(time));
          }
        }

        update(deltaTime, currentTime) {
          this.gameTime += deltaTime * 1000;
          this.timeText.textContent = formatTime(this.gameTime);

          const timeSlowActive = this.activeEffects.timeSlow > currentTime;
          const effectiveDelta = timeSlowActive ? deltaTime * 0.5 : deltaTime;

          this.updatePlayer(deltaTime);
          this.updateEnemies(effectiveDelta, currentTime);
          this.updateProjectiles(deltaTime);
          this.updateEnemyProjectiles(deltaTime);
          this.updateXPOrbs(deltaTime);
          this.updateItems(deltaTime);
          this.updateEffects(currentTime);
          this.updateBuffsUI();

          this.shoot(currentTime);
          this.spawnEnemies(currentTime);

          // ÂΩì„Åü„ÇäÂà§ÂÆöÔºà„É¢„Éê„Ç§„É´„ÅØ2„Éï„É¨„Éº„É†„Å´1ÂõûÔºâ
          this.collisionCheckFrame++;
          if (!this.isMobile || this.collisionCheckFrame % 2 === 0) {
            this.checkCollisions();
          }
        }

        updatePlayer(deltaTime) {
          let dx = 0;
          let dy = 0;

          // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ
          let keyboardInput = false;
          if (this.keys['w'] || this.keys['arrowup']) { dy -= 1; keyboardInput = true; }
          if (this.keys['s'] || this.keys['arrowdown']) { dy += 1; keyboardInput = true; }
          if (this.keys['a'] || this.keys['arrowleft']) { dx -= 1; keyboardInput = true; }
          if (this.keys['d'] || this.keys['arrowright']) { dx += 1; keyboardInput = true; }

          // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ„Åå„ÅÇ„Å£„Åü„Çâ„Éû„Ç¶„Çπ„Çø„Éº„Ç≤„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢
          if (keyboardInput) {
            this.mouseTarget = null;
          }

          // „Éû„Ç¶„Çπ„Çø„Éº„Ç≤„ÉÉ„Éà„Åå„ÅÇ„ÇãÂ†¥Âêà
          if (!keyboardInput && this.mouseTarget) {
            const targetDx = this.mouseTarget.x - this.player.position.x;
            const targetDy = this.mouseTarget.y - this.player.position.y;
            const distance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);

            // ÁõÆÊ®ôÂú∞ÁÇπ„Å´ÂçÅÂàÜËøë„Å•„ÅÑ„Åü„ÇâÂÅúÊ≠¢
            if (distance < 5) {
              this.mouseTarget = null;
            } else {
              dx = targetDx / distance;
              dy = targetDy / distance;
            }
          }

          if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx * dx + dy * dy);
            dx /= length;
            dy /= length;

            let speedMultiplier = this.activeEffects.speedBoost > performance.now() ? 1.5 : 1.0;
            
            // „Éá„Éê„ÉïÊïµ„ÅÆÁØÑÂõ≤ÂÜÖ„Å´„ÅÑ„ÇãÂ†¥Âêà„ÅØÈÄüÂ∫¶„Çí‰∏ã„Åí„Çã
            if (this.debuffedByEnemy) {
              speedMultiplier *= 0.5;
            }
            
            const speed = this.player.speed * speedMultiplier;

            this.player.position.x += dx * speed * deltaTime;
            this.player.position.y += dy * speed * deltaTime;

            this.player.position.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.position.x));
            this.player.position.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.position.y));
          }
        }

        updateEnemies(deltaTime, currentTime) {
          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            // „ÉÅ„É£„Éº„Ç∏„É£„Éº„ÅÆÁ™ÅÈÄ≤Âá¶ÁêÜ
            if (enemy.type.name === '„ÉÅ„É£„Éº„Ç∏„É£„Éº') {
              if (!enemy.chargeState) {
                enemy.chargeState = 'idle';
                enemy.lastChargeTime = currentTime;
                enemy.chargeDirection = null;
              }

              if (enemy.chargeState === 'idle' && currentTime - enemy.lastChargeTime >= enemy.type.chargeInterval) {
                // Á™ÅÈÄ≤Ê∫ñÂÇôÈñãÂßã
                enemy.chargeState = 'preparing';
                enemy.prepareStartTime = currentTime;
                
                // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆÊñπÂêë„ÇíË®òÈå≤
                const dx = this.player.position.x - enemy.position.x;
                const dy = this.player.position.y - enemy.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                enemy.chargeDirection = { x: dx / distance, y: dy / distance };
              } else if (enemy.chargeState === 'preparing' && currentTime - enemy.prepareStartTime >= 500) {
                // Á™ÅÈÄ≤ÈñãÂßã
                enemy.chargeState = 'charging';
                enemy.chargeStartTime = currentTime;
              } else if (enemy.chargeState === 'charging' && currentTime - enemy.chargeStartTime >= enemy.type.chargeDuration) {
                // Á™ÅÈÄ≤ÁµÇ‰∫Ü
                enemy.chargeState = 'idle';
                enemy.lastChargeTime = currentTime;
                enemy.chargeDirection = null;
              }
            }

            // „Éá„Éê„ÉïÊïµ„ÅÆÁØÑÂõ≤„Éá„Éê„ÉïÂá¶ÁêÜ
            if (enemy.type.name === '„Éá„Éê„ÉïÊïµ') {
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < enemy.type.debuffRange) {
                // „Éó„É¨„Ç§„É§„Éº„ÇíÈÅÖ„Åè„Åô„Çã
                if (!this.debuffedByEnemy) {
                  this.debuffedByEnemy = true;
                }
              }
            }

            // ÁßªÂãïÂá¶ÁêÜ
            let moveSpeed = enemy.speed;
            
            if (enemy.type.name === '„ÉÅ„É£„Éº„Ç∏„É£„Éº' && enemy.chargeState === 'charging' && enemy.chargeDirection) {
              // Á™ÅÈÄ≤‰∏≠„ÅØÈ´òÈÄüÁßªÂãï
              enemy.velocity.x = enemy.chargeDirection.x * enemy.type.chargeSpeed * 50;
              enemy.velocity.y = enemy.chargeDirection.y * enemy.type.chargeSpeed * 50;
            } else if (enemy.type.name === '„ÉÅ„É£„Éº„Ç∏„É£„Éº' && enemy.chargeState === 'preparing') {
              // Ê∫ñÂÇô‰∏≠„ÅØÂÅúÊ≠¢
              enemy.velocity.x = 0;
              enemy.velocity.y = 0;
            } else {
              // ÈÄöÂ∏∏ÁßªÂãï
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance > 0) {
                enemy.velocity.x = (dx / distance) * moveSpeed * 50;
                enemy.velocity.y = (dy / distance) * moveSpeed * 50;
              }
            }

            enemy.position.x += enemy.velocity.x * deltaTime;
            enemy.position.y += enemy.velocity.y * deltaTime;

            // „Ç∑„É•„Éº„Çø„Éº„ÅÆÁÖßÊ∫ñÊõ¥Êñ∞
            if (enemy.type.name === '„Ç∑„É•„Éº„Çø„Éº' || enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
              enemy.targetX = this.player.position.x;
              enemy.targetY = this.player.position.y;
            }

            if (enemy.damageFlash > 0) {
              enemy.damageFlash -= deltaTime * 1000;
            }

            // „Ç∑„É•„Éº„Çø„ÉºÁ≥ª„ÅÆÊïµ„ÅÆÂ∞ÑÊíÉ
            if ((enemy.type.name === '„Ç∑„É•„Éº„Çø„Éº' || enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') && 
                currentTime - enemy.lastShootTime >= enemy.type.shootInterval) {
              this.enemyShoot(enemy);
              enemy.lastShootTime = currentTime;
            }
          });

          // „Éá„Éê„ÉïËß£Èô§„ÉÅ„Çß„ÉÉ„ÇØ
          this.debuffedByEnemy = false;
          this.enemies.forEach(enemy => {
            if (enemy.isAlive && enemy.type.name === '„Éá„Éê„ÉïÊïµ') {
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < enemy.type.debuffRange) {
                this.debuffedByEnemy = true;
              }
            }
          });

          this.enemies = this.enemies.filter(e => e.isAlive);
        }

        enemyShoot(enemy) {
          const dx = this.player.position.x - enemy.position.x;
          const dy = this.player.position.y - enemy.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance === 0) return;

          const speed = 200;
          this.enemyProjectiles.push({
            position: { x: enemy.position.x, y: enemy.position.y },
            velocity: { x: (dx / distance) * speed, y: (dy / distance) * speed },
            radius: 5,
            damage: enemy.type.damage,
            isAlive: true,
          });
        }

        updateProjectiles(deltaTime) {
          this.projectiles.forEach(proj => {
            if (!proj.isAlive) return;

            proj.position.x += proj.velocity.x * deltaTime;
            proj.position.y += proj.velocity.y * deltaTime;

            if (proj.position.x < 0 || proj.position.x > this.canvas.width ||
                proj.position.y < 0 || proj.position.y > this.canvas.height) {
              proj.isAlive = false;
            }
          });

          this.projectiles = this.projectiles.filter(p => p.isAlive);
        }

        updateEnemyProjectiles(deltaTime) {
          this.enemyProjectiles.forEach(proj => {
            if (!proj.isAlive) return;

            proj.position.x += proj.velocity.x * deltaTime;
            proj.position.y += proj.velocity.y * deltaTime;

            if (proj.position.x < 0 || proj.position.x > this.canvas.width ||
                proj.position.y < 0 || proj.position.y > this.canvas.height) {
              proj.isAlive = false;
            }
          });

          this.enemyProjectiles = this.enemyProjectiles.filter(p => p.isAlive);
        }

        updateXPOrbs(deltaTime) {
          const magnetActive = this.activeEffects.magnet > performance.now();
          const magnetRadius = magnetActive ? 200 : 100;

          this.xpOrbs.forEach(orb => {
            const dx = this.player.position.x - orb.position.x;
            const dy = this.player.position.y - orb.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < magnetRadius) {
              const speed = magnetActive ? 400 : 200;
              orb.position.x += (dx / distance) * speed * deltaTime;
              orb.position.y += (dy / distance) * speed * deltaTime;
            }
          });
        }

        updateItems(deltaTime) {
          this.items.forEach(item => {
            if (!item.isAlive) return;

            item.lifetime += deltaTime * 1000;
            if (item.lifetime > 15000) {
              item.isAlive = false;
            }
          });

          this.items = this.items.filter(i => i.isAlive);
        }

        updateEffects(currentTime) {
          Object.keys(this.activeEffects).forEach(key => {
            if (this.activeEffects[key] > 0 && this.activeEffects[key] < currentTime) {
              this.activeEffects[key] = 0;
            }
          });
        }

        shoot(currentTime) {
          const shootDelay = 1000 / this.player.attackSpeed;

          if (currentTime - this.lastShootTime < shootDelay) return;

          const nearestEnemy = this.findNearestEnemy();
          if (!nearestEnemy) return;

          const dx = nearestEnemy.position.x - this.player.position.x;
          const dy = nearestEnemy.position.y - this.player.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > this.player.range) return;

          const powerUpActive = this.activeEffects.powerUp > currentTime;
          const damageMultiplier = powerUpActive ? 2.0 : 1.0;

          // Ë§áÊï∞„ÅÆÂºæ„ÇíÁô∫Â∞Ñ
          const count = this.player.projectileCount;
          
          for (let i = 0; i < count; i++) {
            let finalAngle;
            
            if (i === 0) {
              // 1Áô∫ÁõÆ„ÅØÊïµ„Å´Âêë„Åã„Å£„Å¶Áô∫Â∞Ñ
              finalAngle = Math.atan2(dy, dx);
            } else {
              // 2Áô∫ÁõÆ‰ª•Èôç„ÅØ„É©„É≥„ÉÄ„É†„Å™ÊñπÂêë
              finalAngle = Math.random() * Math.PI * 2;
            }
            
            this.projectiles.push({
              position: { x: this.player.position.x, y: this.player.position.y },
              velocity: { 
                x: Math.cos(finalAngle) * this.player.projectileSpeed, 
                y: Math.sin(finalAngle) * this.player.projectileSpeed 
              },
              radius: 5 * this.player.projectileSize,
              damage: this.player.damage * damageMultiplier,
              piercing: this.player.piercing,
              isAlive: true,
            });
          }

          this.lastShootTime = currentTime;
        }

        findNearestEnemy() {
          let nearest = null;
          let minDist = Infinity;

          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            const dx = enemy.position.x - this.player.position.x;
            const dy = enemy.position.y - this.player.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < minDist) {
              minDist = dist;
              nearest = enemy;
            }
          });

          return nearest;
        }

        spawnEnemies(currentTime) {
          if (currentTime - this.lastEnemySpawnTime > this.enemySpawnInterval) {
            const count = Math.min(3, 1 + Math.floor(this.gameTime / 45000));
            
            for (let i = 0; i < count; i++) {
              this.spawnEnemy();
            }
            
            this.lastEnemySpawnTime = currentTime;
            this.enemySpawnInterval = Math.max(800, 1500 - this.gameTime / 150);
          }
        }

        spawnEnemy() {
          // Êïµ„ÅÆÊï∞„ÅåÊúÄÂ§ßÊï∞„ÇíË∂Ö„Åà„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁîüÊàê„Åó„Å™„ÅÑ
          const aliveEnemies = this.enemies.filter(e => e.isAlive).length;
          if (aliveEnemies >= this.maxEnemies) {
            return;
          }
          
          const type = getRandomEnemyType(this.player.level);
          const side = Math.floor(Math.random() * 4);
          let x, y;

          switch (side) {
            case 0: x = Math.random() * this.canvas.width; y = -20; break;
            case 1: x = this.canvas.width + 20; y = Math.random() * this.canvas.height; break;
            case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 20; break;
            case 3: x = -20; y = Math.random() * this.canvas.height; break;
          }

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 15,
            speed: type.speed,
            hp: this.isMobile ? type.hp * 1.2 : type.hp, // „É¢„Éê„Ç§„É´„ÅØÊïµ„ÅÆHP„Çí20%Â¢óÂä†
            maxHp: this.isMobile ? type.hp * 1.2 : type.hp,
            damage: type.damage,
            xpValue: this.isMobile ? type.xp * 1.3 : type.xp, // „É¢„Éê„Ç§„É´„ÅØXPÁç≤ÂæóÈáè„Çí30%Â¢óÂä†
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: type.splitCount || 0,
          });
        }

        spawnMiniBoss() {
          const type = ENEMY_TYPES.MINIBOSS;
          const side = Math.floor(Math.random() * 4);
          let x, y;

          switch (side) {
            case 0: x = this.canvas.width / 2; y = -30; break;
            case 1: x = this.canvas.width + 30; y = this.canvas.height / 2; break;
            case 2: x = this.canvas.width / 2; y = this.canvas.height + 30; break;
            case 3: x = -30; y = this.canvas.height / 2; break;
          }

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 30,
            speed: type.speed,
            hp: type.hp,
            maxHp: type.hp,
            damage: type.damage,
            xpValue: type.xp,
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: 0,
          });
        }

        spawnFinalBoss() {
          const type = ENEMY_TYPES.FINALBOSS;
          
          // ÁîªÈù¢‰∏≠Â§Æ‰∏ä„Åã„ÇâÁôªÂ†¥
          const x = this.canvas.width / 2;
          const y = -50;

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 50,
            speed: type.speed,
            hp: type.hp,
            maxHp: type.hp,
            damage: type.damage,
            xpValue: type.xp,
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: 0,
          });
          
          // ÊúÄÁµÇ„Éú„ÇπBGM„Å´Âàá„ÇäÊõø„Åà
          this.playBGM('finalboss');
        }

        checkCollisions() {
          // „Éó„É¨„Ç§„É§„Éº„ÅÆÂºæ„Å®Êïµ
          this.projectiles.forEach(proj => {
            if (!proj.isAlive) return;

            this.enemies.forEach(enemy => {
              if (!enemy.isAlive) return;

              const dx = proj.position.x - enemy.position.x;
              const dy = proj.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < proj.radius + enemy.radius) {
                enemy.hp -= proj.damage;
                enemy.damageFlash = 200;
                this.stats.damageDealt += proj.damage;
                
                // Êïµ„Å´ÊîªÊíÉ„ÅåÂΩì„Åü„Å£„ÅüÂäπÊûúÈü≥
                this.playSFX('enemyHit');

                if (proj.piercing > 0) {
                  proj.piercing--;
                } else {
                  proj.isAlive = false;
                }

                if (enemy.hp <= 0) {
                  enemy.isAlive = false;
                  this.stats.enemiesKilled++;
                  
                  // „Éú„ÇπÊíÉÁ†¥„ÅÆÂäπÊûúÈü≥
                  if (enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
                    this.playSFX('bossDeath');
                  } else {
                    // ÈÄöÂ∏∏ÊïµÊíÉÁ†¥„ÅÆÂäπÊûúÈü≥
                    this.playSFX('enemyDeath');
                  }
                  
                  this.spawnXPOrb(enemy.position.x, enemy.position.y, enemy.xpValue, enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ');

                  // ÊúÄÁµÇ„Éú„Çπ„ÇíÂÄí„Åó„Åü„Çâ„ÇØ„É™„Ç¢
                  if (enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
                    this.gameClear();
                    return;
                  }

                  // „Çπ„Éó„É™„ÉÉ„Çø„Éº„ÅØÂÄí„Åô„Å®ÂàÜË£Ç„Åô„Çã
                  if (enemy.type.name === '„Çπ„Éó„É™„ÉÉ„Çø„Éº' && enemy.splitCount && enemy.splitCount > 0) {
                    for (let i = 0; i < enemy.type.splitCount; i++) {
                      const angle = (Math.PI * 2 / enemy.type.splitCount) * i;
                      const offsetX = Math.cos(angle) * 30;
                      const offsetY = Math.sin(angle) * 30;
                      
                      this.enemies.push({
                        type: enemy.type,
                        position: { x: enemy.position.x + offsetX, y: enemy.position.y + offsetY },
                        velocity: { x: 0, y: 0 },
                        radius: enemy.radius * 0.7,
                        speed: enemy.speed * 1.2,
                        hp: enemy.maxHp * 0.5,
                        maxHp: enemy.maxHp * 0.5,
                        damage: enemy.damage * 0.7,
                        xpValue: Math.ceil(enemy.xpValue * 0.5),
                        isAlive: true,
                        damageFlash: 0,
                        lastShootTime: 0,
                        targetX: this.player.position.x,
                        targetY: this.player.position.y,
                        splitCount: 0, // ÂàÜË£ÇÊ∏à„Åø„ÅØ„ÇÇ„ÅÜÂàÜË£Ç„Åó„Å™„ÅÑ
                      });
                    }
                  }

                  if (Math.random() < 0.1) {
                    this.spawnItem(enemy.position.x, enemy.position.y);
                  }
                }
              }
            });
          });

          // Êïµ„ÅÆÂºæ„Å®„Éó„É¨„Ç§„É§„Éº
          this.enemyProjectiles.forEach(proj => {
            if (!proj.isAlive) return;

            const dx = proj.position.x - this.player.position.x;
            const dy = proj.position.y - this.player.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < proj.radius + this.player.radius) {
              proj.isAlive = false;
              this.damagePlayer(proj.damage, performance.now());
            }
          });

          // „Éó„É¨„Ç§„É§„Éº„Å®ÁµåÈ®ìÂÄ§„Ç™„Éº„Éñ
          this.xpOrbs.forEach((orb, index) => {
            const dx = this.player.position.x - orb.position.x;
            const dy = this.player.position.y - orb.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + orb.radius) {
              this.player.xp += orb.value;
              this.xpOrbs.splice(index, 1);
              // „Ç™„Éº„ÉñÂèñÂæóÂäπÊûúÈü≥
              this.playSFX('gemGet');
              this.updateUI();
              this.checkLevelUp();
            }
          });

          // „Éó„É¨„Ç§„É§„Éº„Å®„Ç¢„Ç§„ÉÜ„É†
          this.items.forEach((item, index) => {
            if (!item.isAlive) return;

            const dx = this.player.position.x - item.position.x;
            const dy = this.player.position.y - item.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + item.radius) {
              this.applyItemEffect(item);
              item.isAlive = false;
              // „Ç¢„Ç§„ÉÜ„É†ÂèñÂæóÂäπÊûúÈü≥
              this.playSFX('itemGet');
            }
          });

          // „Éó„É¨„Ç§„É§„Éº„Å®Êïµ„ÅÆÊé•Ëß¶
          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            const dx = this.player.position.x - enemy.position.x;
            const dy = this.player.position.y - enemy.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + enemy.radius) {
              this.damagePlayer(enemy.damage, performance.now());
            }
          });
        }

        damagePlayer(damage, currentTime) {
          // ÁÑ°ÊïµÊôÇÈñì‰∏≠„ÅØ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å™„ÅÑ
          if (this.activeEffects.invincible > currentTime) return;
          
          // „ÉÄ„É°„Éº„Ç∏„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„ÅØ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å™„ÅÑ
          if (currentTime - this.player.lastDamageTime < this.player.damageCooldown) return;

          if (this.player.shield > 0) {
            this.player.shield = Math.max(0, this.player.shield - damage);
            this.player.lastDamageTime = currentTime;
            // „Éó„É¨„Ç§„É§„Éº„ÉÄ„É°„Éº„Ç∏ÂäπÊûúÈü≥
            this.playSFX('playerHit');
            return;
          }

          this.player.hp = Math.max(0, this.player.hp - damage);
          this.player.lastDamageTime = currentTime;
          // „Éó„É¨„Ç§„É§„Éº„ÉÄ„É°„Éº„Ç∏ÂäπÊûúÈü≥
          this.playSFX('playerHit');
          this.updateUI();

          if (this.player.hp <= 0) {
            this.gameOver();
          }
        }

        spawnXPOrb(x, y, value, isBossOrb = false) {
          this.xpOrbs.push({
            position: { x, y },
            radius: isBossOrb ? 12 : 6,
            value: value,
            isBossOrb: isBossOrb,
          });
        }

        spawnItem(x, y) {
          const items = [
            { type: 'heal', emoji: '‚ù§Ô∏è', color: '#ff6b6b', name: 'ÂõûÂæ©' },
            { type: 'speedBoost', emoji: '‚ö°', color: '#feca57', name: '„Çπ„Éî„Éº„Éâ„Éñ„Éº„Çπ„Éà' },
            { type: 'powerUp', emoji: 'üí™', color: '#ff6348', name: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó' },
            { type: 'timeSlow', emoji: 'üåÄ', color: '#5f27cd', name: '„Çø„Ç§„É†„Çπ„É≠„Éº' },
            { type: 'invincible', emoji: '‚ú®', color: '#ff9ff3', name: 'ÁÑ°Êïµ' },
            { type: 'magnet', emoji: 'üéØ', color: '#54a0ff', name: '„Éû„Ç∞„Éç„ÉÉ„Éà' },
          ];

          const item = items[Math.floor(Math.random() * items.length)];
          
          this.items.push({
            ...item,
            position: { x, y },
            radius: 12,
            isAlive: true,
            lifetime: 0,
          });
        }

        applyItemEffect(item) {
          const currentTime = performance.now();
          
          this.itemNotification = item;
          this.itemNotificationTime = currentTime;

          switch (item.type) {
            case 'heal':
              this.player.hp = Math.min(this.player.maxHp, this.player.hp + 30);
              break;
            case 'speedBoost':
              this.activeEffects.speedBoost = currentTime + 5000;
              break;
            case 'powerUp':
              this.activeEffects.powerUp = currentTime + 8000;
              break;
            case 'timeSlow':
              this.activeEffects.timeSlow = currentTime + 5000;
              break;
            case 'invincible':
              this.activeEffects.invincible = currentTime + 3000;
              this.player.invincibleUntil = currentTime + 3000;
              break;
            case 'magnet':
              this.activeEffects.magnet = currentTime + 10000;
              break;
          }

          this.updateUI();
        }

        checkLevelUp() {
          if (this.player.xp >= this.player.xpToNextLevel) {
            this.player.xp -= this.player.xpToNextLevel;
            this.player.level++;
            // „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Å´ÂøÖË¶Å„Å™ÁµåÈ®ìÂÄ§„ÅÆÂ¢óÂä†Áéá„Çí1.5‚Üí1.3„Å´Â§âÊõ¥
            this.player.xpToNextLevel = Math.floor(this.player.xpToNextLevel * 1.3);
            
            // 5„ÅÆÂÄçÊï∞„ÅÆ„É¨„Éô„É´„Åß‰∏≠„Éú„ÇπÂá∫Áèæ
            if (this.player.level % 5 === 0 && this.player.level < 20 && this.player.level > this.lastBossLevel) {
              this.spawnMiniBoss();
              this.lastBossLevel = this.player.level;
            }
            
            // „É¨„Éô„É´20„ÅßÊúÄÁµÇ„Éú„ÇπÂá∫Áèæ
            if (this.player.level === 20 && !this.finalBossSpawned) {
              this.spawnFinalBoss();
              this.finalBossSpawned = true;
            }
            
            this.isPaused = true;
            this.showLevelUpModal();
            this.updateUI();
          }
        }

        showLevelUpModal() {
          const upgrades = [
            { 
              id: 'damage', 
              name: '‚ú® ÊîªÊíÉÂäõ„Ç¢„ÉÉ„Éó', 
              description: '„ÉÄ„É°„Éº„Ç∏„Åå20%Â¢óÂä†',
              apply: () => this.player.damage *= 1.20
            },
            { 
              id: 'attackSpeed', 
              name: '‚ö° ÊîªÊíÉÈÄüÂ∫¶„Ç¢„ÉÉ„Éó', 
              description: 'ÊîªÊíÉÈñìÈöî„ÅåÁü≠„Åè„Å™„ÇãÔºà20%UPÔºâ',
              apply: () => this.player.attackSpeed *= 1.2
            },
            { 
              id: 'speed', 
              name: 'üèÉ ÁßªÂãïÈÄüÂ∫¶„Ç¢„ÉÉ„Éó', 
              description: 'ÈÄü„ÅèÂãï„Åë„Çã„Çà„ÅÜ„Å´„Å™„ÇãÔºà15%UPÔºâ',
              apply: () => this.player.speed *= 1.15
            },
            { 
              id: 'maxHp', 
              name: '‚ù§Ô∏è ÊúÄÂ§ßHP„Ç¢„ÉÉ„Éó', 
              description: 'ÊúÄÂ§ßHP„Åå20Â¢ó„Åà„Å¶ÂÖ®ÂõûÂæ©',
              apply: () => {
                this.player.maxHp += 20;
                this.player.hp = this.player.maxHp;
              }
            },
            { 
              id: 'projectileCount', 
              name: 'üåü ÂºæÊï∞Â¢óÂä†', 
              description: 'ÊµÅ„ÇåÊòü„ÅÆÊï∞„Åå1„Å§Â¢ó„Åà„ÇãÔºà1Áô∫„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÅØ20%Ê∏õÔºâ',
              apply: () => {
                this.player.projectileCount += 1;
                this.player.damage *= 0.8; // 1Áô∫„ÅÇ„Åü„Çä„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí20%Ê∏õÂ∞ë
              }
            },
            { 
              id: 'piercing', 
              name: 'üí• Ë≤´ÈÄöÂäõ„Ç¢„ÉÉ„Éó', 
              description: 'ÊµÅ„ÇåÊòü„ÅåÊïµ„ÇíË≤´ÈÄö„Åô„ÇãÔºà+1Ôºâ',
              apply: () => this.player.piercing += 1
            },
          ];

          const selected = [];
          while (selected.length < 3) {
            const upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
            if (!selected.includes(upgrade)) {
              selected.push(upgrade);
            }
          }

          this.upgradeOptions.innerHTML = '';
          selected.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.innerHTML = `
              <h3>${upgrade.name}</h3>
              <p>${upgrade.description}</p>
            `;
            card.addEventListener('click', () => {
              upgrade.apply();
              this.updateUI();
              this.levelupModal.classList.add('hidden');
              this.isPaused = false;
              this.lastTime = performance.now();
              this.gameLoop(this.lastTime);
            });
            this.upgradeOptions.appendChild(card);
          });

          this.levelupModal.classList.remove('hidden');
        }

        updateUI() {
          this.hpFill.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
          this.hpText.textContent = `${Math.floor(this.player.hp)}/${this.player.maxHp}`;

          this.xpFill.style.width = `${(this.player.xp / this.player.xpToNextLevel) * 100}%`;
          this.xpText.textContent = `${Math.floor(this.player.xp)}/${this.player.xpToNextLevel}`;

          this.levelText.textContent = this.player.level;
        }

        updateBuffsUI() {
          const currentTime = performance.now();
          this.buffsContainer.innerHTML = '';
          
          const activeBuffs = [];
          
          if (this.activeEffects.speedBoost) {
            activeBuffs.push({
              name: '„Çπ„Éî„Éº„Éâ„Éñ„Éº„Çπ„Éà',
              emoji: '‚ö°',
              color: '#feca57',
              endTime: this.activeEffects.speedBoost,
              duration: 5000,
            });
          }
          
          if (this.activeEffects.powerUp) {
            activeBuffs.push({
              name: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó',
              emoji: 'üí™',
              color: '#ff6348',
              endTime: this.activeEffects.powerUp,
              duration: 8000,
            });
          }
          
          if (this.activeEffects.timeSlow) {
            activeBuffs.push({
              name: '„Çø„Ç§„É†„Çπ„É≠„Éº',
              emoji: 'üåÄ',
              color: '#5f27cd',
              endTime: this.activeEffects.timeSlow,
              duration: 5000,
            });
          }
          
          if (this.activeEffects.invincible) {
            activeBuffs.push({
              name: 'ÁÑ°Êïµ',
              emoji: '‚ú®',
              color: '#ff9ff3',
              endTime: this.activeEffects.invincible,
              duration: 3000,
            });
          }
          
          if (this.activeEffects.magnet) {
            activeBuffs.push({
              name: '„Éû„Ç∞„Éç„ÉÉ„Éà',
              emoji: 'üéØ',
              color: '#54a0ff',
              endTime: this.activeEffects.magnet,
              duration: 10000,
            });
          }
          
          if (this.player.shield && this.player.shield > 0) {
            activeBuffs.push({
              name: '„Ç∑„Éº„É´„Éâ',
              emoji: 'üõ°Ô∏è',
              color: '#48dbfb',
              endTime: null,
              duration: null,
            });
          }
          
          activeBuffs.forEach(buff => {
            const buffEl = document.createElement('div');
            buffEl.className = 'buff-item';
            buffEl.style.borderColor = buff.color;
            
            let timerHTML = '';
            if (buff.endTime) {
              const remaining = Math.max(0, buff.endTime - currentTime);
              const percent = (remaining / buff.duration) * 100;
              timerHTML = `
                <div class="buff-timer">
                  <div class="buff-timer-fill" style="width: ${percent}%; background: ${buff.color}"></div>
                </div>
              `;
            }
            
            buffEl.innerHTML = `
              <span class="buff-icon">${buff.emoji}</span>
              <div class="buff-info">
                <div class="buff-name">${buff.name}</div>
                ${timerHTML}
              </div>
            `;
            
            this.buffsContainer.appendChild(buffEl);
          });
        }

        gameOver() {
          this.isGameOver = true;
          this.stats.timeAlive = this.gameTime;
          this.stats.level = this.player.level;
          this.stopBGM();
          
          // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºBGM„ÇíÂÜçÁîü
          this.playBGM('gameover');

          const statsText = `
            ÁîüÂ≠òÊôÇÈñì: ${formatTime(this.stats.timeAlive)}<br>
            „É¨„Éô„É´: ${this.stats.level}<br>
            ÂÄí„Åó„ÅüÊïµ: ${this.stats.enemiesKilled}‰Ωì<br>
            ‰∏é„Åà„Åü„ÉÄ„É°„Éº„Ç∏: ${Math.floor(this.stats.damageDealt)}
          `;
          
          document.getElementById('final-stats').innerHTML = statsText;
          this.gameoverModal.classList.remove('hidden');
        }

        gameClear() {
          this.isGameOver = true;
          this.stats.timeAlive = this.gameTime;
          this.stats.level = this.player.level;
          this.stopBGM();
          
          // „ÇØ„É™„Ç¢BGM„ÇíÂÜçÁîü
          this.playBGM('clear');

          const statsText = `
            „ÇØ„É™„Ç¢ÊôÇÈñì: ${formatTime(this.stats.timeAlive)}<br>
            ÊúÄÁµÇ„É¨„Éô„É´: ${this.stats.level}<br>
            ÂÄí„Åó„ÅüÊïµ: ${this.stats.enemiesKilled}‰Ωì<br>
            ‰∏é„Åà„Åü„ÉÄ„É°„Éº„Ç∏: ${Math.floor(this.stats.damageDealt)}
          `;
          
          document.getElementById('clear-stats').innerHTML = statsText;
          this.gameclearModal.classList.remove('hidden');
        }

        render() {
          const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
          gradient.addColorStop(0, '#0f0c29');
          gradient.addColorStop(0.5, '#302b63');
          gradient.addColorStop(1, '#24243e');
          
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // ËÉåÊôØ„ÅÆÊòüÔºà„É¢„Éê„Ç§„É´„ÅØ20ÂÄã„ÄÅPC„ÅØ50ÂÄãÔºâ
          const starCount = this.isMobile ? 20 : 50;
          this.ctx.fillStyle = '#ffffff';
          for (let i = 0; i < starCount; i++) {
            const x = (i * 137.5) % this.canvas.width;
            const y = (i * 213.7) % this.canvas.height;
            this.ctx.fillRect(x, y, 1, 1);
          }

          this.xpOrbs.forEach(orb => {
            this.ctx.save();
            
            const time = performance.now() / 300;
            const pulse = Math.sin(time) * 0.2 + 1;
            
            if (orb.isBossOrb) {
              // ‰∏≠„Éú„Çπ„Ç™„Éº„Éñ: „Ç≠„É©„Ç≠„É©„Ç®„Éï„Çß„ÇØ„Éà
              this.ctx.shadowColor = '#ffd700';
              this.ctx.shadowBlur = 25;
              
              const angle = time % (Math.PI * 2);
              const gradient = this.ctx.createRadialGradient(
                orb.position.x, orb.position.y, 0,
                orb.position.x, orb.position.y, orb.radius * pulse
              );
              
              const hue = (time * 50) % 360;
              gradient.addColorStop(0, `hsl(${hue}, 100%, 90%)`);
              gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 100%, 70%)`);
              gradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
              
              this.ctx.beginPath();
              this.ctx.arc(orb.position.x, orb.position.y, orb.radius * pulse, 0, Math.PI * 2);
              this.ctx.fillStyle = gradient;
              this.ctx.fill();
              
              this.ctx.strokeStyle = '#ffd700';
              this.ctx.lineWidth = 3;
              this.ctx.stroke();
              
              // „Ç≠„É©„Ç≠„É©Êòü
              for (let i = 0; i < 4; i++) {
                const starAngle = angle + (i * Math.PI / 2);
                const starDist = orb.radius * pulse + 5;
                const starX = orb.position.x + Math.cos(starAngle) * starDist;
                const starY = orb.position.y + Math.sin(starAngle) * starDist;
                
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(starX, starY, 3, 0, Math.PI * 2);
                this.ctx.fill();
              }
            } else {
              // ÈÄöÂ∏∏„Ç™„Éº„Éñ: Êòé„Çã„ÅÑÈùíÁ∑ë„ÅßÂÖâ„ÇãÂÖ≠ËßíÂΩ¢
              this.ctx.shadowColor = '#00ffff';
              this.ctx.shadowBlur = 15;
              
              const gradient = this.ctx.createRadialGradient(
                orb.position.x, orb.position.y, 0,
                orb.position.x, orb.position.y, orb.radius * pulse
              );
              gradient.addColorStop(0, '#ffffff');
              gradient.addColorStop(0.4, '#00ffff');
              gradient.addColorStop(1, '#00cccc');
              
              // ÂÖ≠ËßíÂΩ¢
              this.ctx.beginPath();
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i + time;
                const x = orb.position.x + Math.cos(angle) * orb.radius * pulse;
                const y = orb.position.y + Math.sin(angle) * orb.radius * pulse;
                if (i === 0) this.ctx.moveTo(x, y);
                else this.ctx.lineTo(x, y);
              }
              this.ctx.closePath();
              this.ctx.fillStyle = gradient;
              this.ctx.fill();
              
              this.ctx.strokeStyle = '#ffffff';
              this.ctx.lineWidth = 2;
              this.ctx.stroke();
              
              // ‰∏≠ÂøÉ„Å´ÂÖâ„ÇãÁÇπ
              this.ctx.fillStyle = '#ffffff';
              this.ctx.beginPath();
              this.ctx.arc(orb.position.x, orb.position.y, 2, 0, Math.PI * 2);
              this.ctx.fill();
            }
            
            this.ctx.restore();
          });

          this.items.forEach(item => {
            if (item.isAlive) {
              drawItem(this.ctx, item);
            }
          });

          this.enemies.forEach(enemy => {
            if (enemy.isAlive) {
              drawEnemy(this.ctx, enemy, this.reducedEffects);
            }
          });

          this.enemyProjectiles.forEach(proj => {
            if (proj.isAlive) {
              this.ctx.save();
              
              // Â§ñÂÅ¥„ÅÆÂº∑„ÅÑÂÖâ
              this.ctx.shadowColor = '#ff0000';
              this.ctx.shadowBlur = 25;
              
              // ÂÖâ„ÅÆ„Ç™„Éº„É©ÔºàÂ§ñÂÅ¥Ôºâ
              const outerGradient = this.ctx.createRadialGradient(
                proj.position.x, proj.position.y, 0,
                proj.position.x, proj.position.y, proj.radius * 3
              );
              outerGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
              outerGradient.addColorStop(0.4, 'rgba(255, 50, 50, 0.4)');
              outerGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
              
              this.ctx.beginPath();
              this.ctx.arc(proj.position.x, proj.position.y, proj.radius * 3, 0, Math.PI * 2);
              this.ctx.fillStyle = outerGradient;
              this.ctx.fill();
              
              // Êú¨‰ΩìÔºàÊòé„Çã„ÅèÔºâ
              this.ctx.shadowBlur = 15;
              this.ctx.shadowColor = '#ff3333';
              
              const bodyGradient = this.ctx.createRadialGradient(
                proj.position.x, proj.position.y, 0,
                proj.position.x, proj.position.y, proj.radius
              );
              bodyGradient.addColorStop(0, '#ffaaaa');
              bodyGradient.addColorStop(0.6, '#ff3333');
              bodyGradient.addColorStop(1, '#cc0000');
              
              this.ctx.beginPath();
              this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
              this.ctx.fillStyle = bodyGradient;
              this.ctx.fill();
              
              // ‰∏≠ÂøÉ„ÅÆÂº∑„ÅÑ„Éè„Ç§„É©„Ç§„Éà
              const highlightGradient = this.ctx.createRadialGradient(
                proj.position.x - proj.radius * 0.3, 
                proj.position.y - proj.radius * 0.3, 
                0,
                proj.position.x, 
                proj.position.y, 
                proj.radius * 0.6
              );
              highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
              highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
              
              this.ctx.beginPath();
              this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
              this.ctx.fillStyle = highlightGradient;
              this.ctx.fill();
              
              // ÂÖâ„ÇãÁ∏ÅÂèñ„Çä
              this.ctx.strokeStyle = '#ffaaaa';
              this.ctx.lineWidth = 2;
              this.ctx.stroke();
              
              this.ctx.restore();
            }
          });

          this.projectiles.forEach(proj => {
            if (proj.isAlive) {
              this.ctx.save();
              this.ctx.translate(proj.position.x, proj.position.y);
              
              const spikes = 5;
              const outerRadius = proj.radius;
              const innerRadius = proj.radius / 2;

              this.ctx.beginPath();
              for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (Math.PI / spikes) * i;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) {
                  this.ctx.moveTo(x, y);
                } else {
                  this.ctx.lineTo(x, y);
                }
              }
              this.ctx.closePath();
              
              this.ctx.fillStyle = '#ffd700';
              this.ctx.fill();
              this.ctx.strokeStyle = '#ffed4e';
              this.ctx.lineWidth = 1;
              this.ctx.stroke();

              this.ctx.restore();
            }
          });

          drawPlayer(this.ctx, this.player, this.playerImage, performance.now());

          if (this.itemNotification) {
            const elapsed = performance.now() - this.itemNotificationTime;
            if (elapsed < 2000) {
              this.ctx.save();
              
              const alpha = elapsed < 1500 ? 1 : 1 - (elapsed - 1500) / 500;
              this.ctx.globalAlpha = alpha;
              
              const y = this.canvas.height / 2 - 100 - (elapsed / 10);
              
              this.ctx.font = 'bold 24px Arial';
              this.ctx.textAlign = 'center';
              this.ctx.textBaseline = 'middle';
              
              this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
              this.ctx.fillRect(this.canvas.width / 2 - 120, y - 20, 240, 50);
              
              this.ctx.fillStyle = this.itemNotification.color;
              this.ctx.fillText(`${this.itemNotification.emoji} ${this.itemNotification.name}`, this.canvas.width / 2, y);
              
              this.ctx.restore();
            } else {
              this.itemNotification = null;
            }
          }
        }
      }

      const canvas = document.getElementById('game-canvas');
      new Game(canvas);

      console.log('üåü „Ç≥„Çπ„É¢„Å™„ÅΩ„Çä„Åü„Çì „Çµ„Éê„Ç§„Éê„Éº„Çπ„Çø„Éº„Ç∫ üçù');
      console.log('WASD„Åæ„Åü„ÅØÊñπÂêë„Ç≠„Éº„ÅßÁßªÂãï„Åó„Å¶„Å≠ÔºÅ');
    })();
  </script>
</body>
</html>

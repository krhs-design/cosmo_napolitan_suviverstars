<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>„Ç≥„Çπ„É¢„Å™„ÅΩ„Çä„Åü„Çì „Çµ„Éê„Ç§„Éê„Éº„Çπ„Çø„Éº„Ç∫ üåü</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', 'Hiragino Sans', 'Meiryo', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
      color: white;
      overflow: hidden;
    }

    #app {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }

    @media (max-width: 820px) {
      #app {
        align-items: flex-start;
        padding-top: 200px; /* HUD„ÅÆÈ´ò„ÅïÂàÜ + ‰ΩôÁôΩ„Çí„Åï„Çâ„Å´Â¢ó„ÇÑ„Åô */
      }
    }

    @media (max-width: 480px) {
      #app {
        padding-top: 250px; /* „Çπ„Éû„Éõ„ÅØ„Åï„Çâ„Å´50px‰∏ã„Å´ */
      }
    }

    #game-container {
      position: relative;
      width: 800px;
      height: 600px;
      max-width: 100vw;
      max-height: 100vh;
      background: #000;
      border: 4px solid #4a90e2;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
    }

    @media (max-width: 820px) {
      #game-container {
        width: 100vw;
        height: calc(100vw * 0.75); /* 4:3„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÁ∂≠ÊåÅ */
        max-height: calc(100vh - 220px); /* HUDÂàÜ„ÅÆÈ´ò„Åï„ÇíÂºï„Åè */
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
    }

    @media (max-height: 620px) {
      #game-container {
        width: calc(100vh * 1.333); /* 4:3„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÁ∂≠ÊåÅ */
        height: 100vh;
        max-width: 100vw;
        border-radius: 0;
        border-top: none;
        border-bottom: none;
      }
    }

    @media (max-width: 820px) and (max-height: 620px) {
      #game-container {
        width: calc(100vh * 1.333);
        height: 100vh;
      }
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }

    @media (max-width: 820px) {
      #hud {
        position: fixed;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
      }
    }

    @media (max-width: 600px) {
      #hud {
        padding: 10px;
        min-width: 150px;
        position: fixed;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
      }

      .hud-item {
        font-size: 12px !important;
      }

      .hp-bar, .xp-bar {
        height: 16px !important;
      }
    }

    #buffs {
      position: absolute;
      bottom: 10px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    @media (max-width: 600px) {
      #buffs {
        bottom: 5px;
        left: 5px;
      }

      .buff-item {
        padding: 6px 10px !important;
        min-width: 120px !important;
      }

      .buff-icon {
        font-size: 16px !important;
      }

      .buff-name {
        font-size: 10px !important;
      }
    }

    .buff-item {
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 150px;
      border: 2px solid;
    }

    .buff-icon {
      font-size: 20px;
    }

    .buff-info {
      flex: 1;
    }

    .buff-name {
      font-size: 12px;
      font-weight: bold;
    }

    .buff-timer {
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 4px;
    }

    .buff-timer-fill {
      height: 100%;
      background: white;
      transition: width 0.1s linear;
    }

    #pause-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: 3px solid #4a90e2;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      transition: all 0.3s;
    }

    @media (max-width: 600px) {
      #pause-btn {
        width: 40px;
        height: 40px;
        top: 5px;
        right: 5px;
      }

      #pause-btn .pause-icon {
        width: 16px !important;
        height: 20px !important;
      }

      #pause-btn .pause-icon::before,
      #pause-btn .pause-icon::after {
        width: 5px !important;
        height: 20px !important;
      }

      #pause-btn.paused .pause-icon::before {
        border-width: 10px 0 10px 16px !important;
        left: 4px !important;
      }
    }

    #pause-btn:hover {
      background: rgba(74, 144, 226, 0.3);
      transform: scale(1.1);
    }

    #pause-btn .pause-icon {
      width: 20px;
      height: 24px;
      position: relative;
    }

    #pause-btn .pause-icon::before,
    #pause-btn .pause-icon::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 24px;
      background: white;
      border-radius: 2px;
    }

    #pause-btn .pause-icon::before {
      left: 0;
    }

    #pause-btn .pause-icon::after {
      right: 0;
    }

    #pause-btn.paused .pause-icon::before {
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 12px 0 12px 20px;
      border-color: transparent transparent transparent white;
      background: transparent;
      left: 5px;
      top: 0;
    }

    #pause-btn.paused .pause-icon::after {
      display: none;
    }

    .hud-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .hp-bar, .xp-bar {
      flex: 1;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ee5a6f);
      transition: width 0.3s ease;
      width: 100%;
    }

    .xp-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #44a08d);
      transition: width 0.3s ease;
      width: 0%;
    }

    .modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: all;
      z-index: 100;
    }

    @media (max-width: 600px) {
      .modal {
        align-items: flex-start;
        padding-top: 0;
      }
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 500px;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
    }

    @media (max-width: 600px) {
      .modal-content {
        max-width: 90vw;
        padding: 15px;
        margin-top: -30px;
      }

      .modal-content h1 {
        font-size: 24px !important;
        margin-bottom: 8px !important;
      }

      .modal-content h2 {
        font-size: 22px !important;
        margin-bottom: 12px !important;
      }

      .modal-content p {
        font-size: 14px !important;
        margin-bottom: 15px !important;
      }

      .upgrade-options {
        gap: 10px !important;
      }

      .upgrade-card {
        padding: 12px !important;
      }

      .upgrade-card h3 {
        font-size: 20px !important;
        margin-bottom: 6px !important;
      }

      .upgrade-card p {
        font-size: 14px !important;
      }

      .btn {
        padding: 10px 20px;
        font-size: 14px;
      }

      .btn-large {
        padding: 12px 32px;
        font-size: 16px;
      }
    }

    @media (max-width: 480px) {
      .modal-content {
        margin-top: -30px !important;
      }
    }

    .modal-content h1 {
      font-size: 36px;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .modal-content h2 {
      font-size: 28px;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .modal-content p {
      font-size: 16px;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      pointer-events: all;
      box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-large {
      padding: 16px 48px;
      font-size: 20px;
    }

    .upgrade-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .upgrade-card {
      background: rgba(255, 255, 255, 0.15);
      padding: 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
      backdrop-filter: blur(10px);
    }

    .upgrade-card:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-4px);
    }

    .upgrade-card h3 {
      font-size: 20px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upgrade-card p {
      font-size: 14px;
      margin: 0;
      opacity: 0.9;
    }

    /* „Éù„Éº„Ç∫„É°„Éã„É•„ÉºÁî®„ÅÆ„Çπ„Çø„Ç§„É´ */
    .sound-setting {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 12px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sound-setting label {
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle-switch.active {
      background: #4caf50;
    }

    .toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(30px);
    }

    .toggle-switch.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(150, 150, 150, 0.3);
    }

    .sound-setting.disabled {
      opacity: 0.5;
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .btn-danger:hover {
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
    }

    .btn-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    .btn-selected {
      background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      
      <div id="ui-overlay">
        <div id="hud">
          <div class="hud-item">
            <span>‚ù§Ô∏è HP:</span>
            <div class="hp-bar">
              <div id="hp-fill" class="hp-fill"></div>
            </div>
            <span id="hp-text">100/100</span>
          </div>
          <div class="hud-item">
            <span>‚≠ê XP:</span>
            <div class="xp-bar">
              <div id="xp-fill" class="xp-fill"></div>
            </div>
            <span id="xp-text">0/10</span>
          </div>
          <div class="hud-item">
            <span>üéØ „É¨„Éô„É´:</span>
            <span id="level-text">1</span>
          </div>
          <div class="hud-item">
            <span>‚è±Ô∏è ÊôÇÈñì:</span>
            <span id="time-text">0:00</span>
          </div>
        </div>

        <div id="buffs"></div>

        <button id="pause-btn" aria-label="„Éù„Éº„Ç∫">
          <div class="pause-icon"></div>
        </button>

        <div id="start-modal" class="modal">
          <div class="modal-content">
            <h1>üåü „Ç≥„Çπ„É¢„Å™„ÅΩ„Çä„Åü„Çì üçù</h1>
            <h2>„Çµ„Éê„Ç§„Éê„Éº„Çπ„Çø„Éº„Ç∫</h2>
            <p>
              WASD„Åæ„Åü„ÅØÊñπÂêë„Ç≠„Éº„ÅßÁßªÂãï„Åó„Çà„ÅÜÔºÅ<br>
              „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ„Åß„ÇÇÁßªÂãï„Åß„Åç„Çã„ÇàÔºÅüñ±Ô∏è<br>
              „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åó„Å¶Âº∑„Åè„Å™„Çä„ÄÅ<br>
              „Éú„Çπ„Çí„Åü„Åä„Åù„ÅÜ!
            </p>
            <div id="music-selection" style="margin-bottom: 20px;">
              <p style="font-size: 18px; margin-bottom: 10px; font-weight: bold;">Èü≥Ê•ΩË®≠ÂÆö</p>
              <button id="music-on-btn" class="btn" style="margin-right: 10px;">üîä Èü≥Ê•Ω„ÅÇ„Çä</button>
              <button id="music-off-btn" class="btn">üîá Èü≥Ê•Ω„Å™„Åó</button>
            </div>
            <button id="start-btn" class="btn btn-large" style="display: none;">„Ç≤„Éº„É†„Çπ„Çø„Éº„Éà üöÄ</button>
          </div>
        </div>

        <div id="levelup-modal" class="modal hidden">
          <div class="modal-content">
            <h2>üéâ „É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ</h2>
            <p>Âº∑Âåñ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</p>
            <div id="upgrade-options" class="upgrade-options"></div>
          </div>
        </div>

        <div id="pause-modal" class="modal hidden">
          <div class="modal-content">
            <h2>‚è∏Ô∏è „Éù„Éº„Ç∫„É°„Éã„É•„Éº</h2>
            
            <div class="sound-setting">
              <label>
                <span>üéµ</span>
                <span>BGM</span>
              </label>
              <div class="toggle-switch active" id="bgm-toggle">
                <div class="toggle-slider"></div>
              </div>
            </div>

            <div class="sound-setting">
              <label>
                <span>üîä</span>
                <span>ÂäπÊûúÈü≥</span>
              </label>
              <div class="toggle-switch active" id="sfx-toggle">
                <div class="toggle-slider"></div>
              </div>
            </div>

            <div class="btn-group">
              <button class="btn btn-large" id="resume-btn">‚ñ∂Ô∏è „Ç≤„Éº„É†„Å´Êàª„Çã</button>
              <button class="btn btn-large btn-danger" id="quit-btn">üö™ „Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü</button>
            </div>
          </div>
        </div>

        <div id="gameover-modal" class="modal hidden">
          <div class="modal-content">
            <h2>üí´ „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h2>
            <div id="final-stats" style="margin: 20px 0; font-size: 18px; line-height: 1.8;"></div>
            <button id="restart-btn" class="btn btn-large">„Çπ„Çø„Éº„ÉàÁîªÈù¢„Å´Êàª„Çã</button>
          </div>
        </div>

        <!-- „Ç≤„Éº„É†„ÇØ„É™„Ç¢„É¢„Éº„ÉÄ„É´ -->
        <div id="gameclear-modal" class="modal hidden">
          <div class="modal-content" style="max-width: 600px;">
            <h2 style="color: #ffd700; font-size: 2.5em; text-shadow: 0 0 20px #ffd700;">üéâ „Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ üéâ</h2>
            <p style="font-size: 1.3em; margin: 20px 0;">ÊúÄÁµÇ„Éú„Çπ„ÇíÊíÉÁ†¥ÔºÅ„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ</p>
            <div id="clear-stats" style="margin: 20px 0; font-size: 18px; line-height: 1.8;"></div>
            <div style="margin: 30px 0;">
              <img src="images/kancho.png" alt="„Ç≥„Çπ„É¢„Éõ„Éº„É´È§®Èï∑" style="max-width: 35%; height: auto; border-radius: 10px; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);">
            </div>
            <button id="restart-clear-btn" class="btn btn-large" style="background: linear-gradient(135deg, #ffd700, #ffed4e); color: #000; font-weight: bold;">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // Êïµ„ÅÆ„Çø„Ç§„ÉóÂÆöÁæ©
      const ENEMY_TYPES = {
        BASIC: {
          name: 'Âü∫Êú¨Êïµ',
          emoji: 'üëæ',
          color: '#ff6b6b',
          secondaryColor: '#e74c3c',
          hp: 22,
          speed: 0.8,
          damage: 5,
          xp: 3,
          spawnWeight: 50,
          minLevel: 1,
        },
        FAST: {
          name: 'ÈÄü„ÅÑÊïµ',
          emoji: '‚ö°',
          color: '#feca57',
          secondaryColor: '#f39c12',
          hp: 12,
          speed: 1.5,
          damage: 4,
          xp: 5,
          spawnWeight: 30,
          minLevel: 3,
        },
        SHOOTER: {
          name: '„Ç∑„É•„Éº„Çø„Éº',
          emoji: 'üåÄ',
          color: '#f39c12',
          secondaryColor: '#e67e22',
          hp: 18,
          speed: 0.7,
          damage: 5,
          xp: 10,
          spawnWeight: 25,
          shootInterval: 2500,
          minLevel: 6,
        },
        TANK: {
          name: '„Çø„É≥„ÇØ',
          emoji: 'üõ°Ô∏è',
          color: '#9b59b6',
          secondaryColor: '#8e44ad',
          hp: 60,
          speed: 0.35,
          damage: 10,
          xp: 25,
          spawnWeight: 20,
          minLevel: 11,
        },
        CHARGER: {
          name: '„ÉÅ„É£„Éº„Ç∏„É£„Éº',
          emoji: 'üí®',
          color: '#e74c3c',
          secondaryColor: '#c0392b',
          hp: 25,
          speed: 0.5,
          damage: 15,
          xp: 20,
          spawnWeight: 15,
          chargeInterval: 3500,
          chargeSpeed: 3.5,
          chargeDuration: 800,
          minLevel: 13,
        },
        DEBUFFER: {
          name: '„Éá„Éê„ÉïÊïµ',
          emoji: 'üíÄ',
          color: '#9b59b6',
          secondaryColor: '#8e44ad',
          hp: 18,
          speed: 0.7,
          damage: 5,
          xp: 18,
          spawnWeight: 15,
          debuffRange: 100,
          minLevel: 15,
        },
        SPLITTER: {
          name: '„Çπ„Éó„É™„ÉÉ„Çø„Éº',
          emoji: 'üîÑ',
          color: '#2ecc71',
          secondaryColor: '#27ae60',
          hp: 30,
          speed: 0.6,
          damage: 8,
          xp: 22,
          spawnWeight: 10,
          splitCount: 2,
          minLevel: 18,
        },
        MINIBOSS: {
          name: '‰∏≠„Éú„Çπ',
          emoji: 'üëë',
          color: '#8b00ff',
          secondaryColor: '#6a00cc',
          hp: 250,
          speed: 0.5,
          damage: 15,
          xp: 50,
          spawnWeight: 0,
          shootInterval: 1800,
          minLevel: 1,
        },
        FINALBOSS: {
          name: 'ÊúÄÁµÇ„Éú„Çπ',
          emoji: 'üî•',
          color: '#ff0000',
          secondaryColor: '#cc0000',
          hp: 800,
          speed: 0.6,
          damage: 20,
          xp: 200,
          spawnWeight: 0,
          shootInterval: 1000,
          minLevel: 20,
        }
      };

      function drawPlayer(ctx, player, img, time, isLowSpec = false, isUltraLowSpec = false) {
        ctx.save();
        
        // ÁÑ°ÊïµÊôÇ„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà
        const isInvincible = player.invincibleUntil && time < player.invincibleUntil;
        
        if (isInvincible) {
          // ËôπËâ≤„ÅÆ„Ç™„Éº„É©
          const hue = (time / 10) % 360;
          // „Çπ„Éû„Éõ„ÅØshadowBlur„Å™„Åó
          if (!isUltraLowSpec) {
            ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
            ctx.shadowBlur = isLowSpec ? 15 : 30;
          }
          
          if (isLowSpec) {
            // ËªΩÈáèÁâà: „Ç∑„É≥„Éó„É´„Å™ËôπËâ≤„ÅÆËº™1„Å§
            const radius = player.radius + 15;
            ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.position.x, player.position.y, radius, 0, Math.PI * 2);
            ctx.stroke();
          } else {
            // ÈÄöÂ∏∏Áâà: ÂõûËª¢„Åô„ÇãËôπËâ≤„ÅÆËº™
            const rotationSpeed = time / 500;
            for (let i = 0; i < 3; i++) {
              const angle = rotationSpeed + (i * Math.PI * 2 / 3);
              const radius = player.radius + 15 + Math.sin(time / 200 + i) * 5;
              
              ctx.strokeStyle = `hsl(${(hue + i * 120) % 360}, 100%, 60%)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(player.position.x, player.position.y, radius, angle, angle + Math.PI);
              ctx.stroke();
            }
            
            // „Ç≠„É©„Ç≠„É©Êòü
            for (let i = 0; i < 6; i++) {
              const starAngle = rotationSpeed * 2 + (i * Math.PI / 3);
              const starDist = player.radius + 20;
              const starX = player.position.x + Math.cos(starAngle) * starDist;
              const starY = player.position.y + Math.sin(starAngle) * starDist;
              const starHue = (hue + i * 60) % 360;
              
              ctx.fillStyle = `hsl(${starHue}, 100%, 80%)`;
              ctx.shadowColor = `hsl(${starHue}, 100%, 70%)`;
              ctx.shadowBlur = 10;
              ctx.beginPath();
              ctx.arc(starX, starY, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
        
        // „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÁõ¥Âæå„ÅØËµ§„ÅèÈÄèÊòéÁÇπÊªÖ
        const timeSinceDamage = time - player.lastDamageTime;
        if (timeSinceDamage < player.damageCooldown && !isInvincible) {
          const flashInterval = 100;
          if (Math.floor(timeSinceDamage / flashInterval) % 2 === 1) {
            ctx.globalAlpha = 0.5;
          }
          // Ëµ§„ÅÑ„ÉÜ„Ç£„É≥„Éà
          ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
          ctx.globalCompositeOperation = 'source-atop';
        }
        
        if (player.shield > 0) {
          const shimmer = Math.sin(time / 200) * 0.3 + 0.7;
          // „Çπ„Éû„Éõ„ÅØshadowBlur„Å™„Åó
          if (!isUltraLowSpec) {
            ctx.shadowColor = `rgba(72, 219, 251, ${shimmer})`;
            ctx.shadowBlur = 20;
          }
          ctx.strokeStyle = `rgba(72, 219, 251, ${shimmer})`;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(player.position.x, player.position.y, player.radius + 10, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        if (img && img.complete) {
          // „Çπ„Éû„Éõ„ÅØÁîªË≥™„Çí‰∏ã„Åí„Çã
          ctx.imageSmoothingEnabled = !isUltraLowSpec;
          ctx.imageSmoothingQuality = isUltraLowSpec ? 'low' : 'high';
          
          ctx.globalCompositeOperation = 'source-over';
          
          // ÁîªÂÉè„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„Çí‰øùÊåÅ
          const imgAspect = img.width / img.height;
          let drawWidth = player.radius * 2;
          let drawHeight = player.radius * 2;
          
          if (imgAspect > 1) {
            // Ê®™Èï∑„ÅÆÁîªÂÉè
            drawHeight = drawWidth / imgAspect;
          } else {
            // Á∏¶Èï∑„ÅÆÁîªÂÉè
            drawWidth = drawHeight * imgAspect;
          }
          
          ctx.drawImage(
            img,
            player.position.x - drawWidth / 2,
            player.position.y - drawHeight / 2,
            drawWidth,
            drawHeight
          );
          
          // „ÉÄ„É°„Éº„Ç∏ÊôÇ„ÅÆËµ§„ÅÑ„Ç™„Éº„Éê„Éº„É¨„Ç§ÔºàÁÑ°ÊïµÊôÇ‰ª•Â§ñÔºâ
          if (timeSinceDamage < player.damageCooldown && !isInvincible) {
            const flashInterval = 100;
            if (Math.floor(timeSinceDamage / flashInterval) % 2 === 1) {
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = 'rgba(255, 100, 100, 0.7)';
              ctx.beginPath();
              ctx.arc(player.position.x, player.position.y, player.radius * 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else {
          ctx.beginPath();
          ctx.arc(player.position.x, player.position.y, player.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ffd700';
          ctx.fill();
          ctx.strokeStyle = '#ffed4e';
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        ctx.restore();
      }

      function drawEnemy(ctx, enemy) {
        ctx.save();
        
        const type = enemy.type;
        const time = performance.now();
        
        // „ÉÄ„É°„Éº„Ç∏„Éï„É©„ÉÉ„Ç∑„É•
        if (enemy.damageFlash > 0) {
          ctx.globalAlpha = 0.5 + (enemy.damageFlash / 200);
        }

        // „Çø„Ç§„Éó„Åî„Å®„Å´Áï∞„Å™„ÇãÊèèÁîª
        switch(type.name) {
          case 'Âü∫Êú¨Êïµ':
            // „Ç∑„É≥„Éó„É´„Å™Ëµ§„ÅÑÂÜÜ
            ctx.beginPath();
            ctx.arc(enemy.position.x, enemy.position.y, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
            
          case 'ÈÄü„ÅÑÊïµ':
            // ÊµÅÁ∑öÂûã„ÅÆÈùí„ÅÑÂΩ¢„ÄÅÂæå„Çç„Å´Â∞æ
            ctx.translate(enemy.position.x, enemy.position.y);
            const angle = Math.atan2(enemy.velocity.y, enemy.velocity.x);
            ctx.rotate(angle);
            
            // Êú¨‰ΩìÔºàÊµÅÁ∑öÂûãÔºâ
            ctx.beginPath();
            ctx.ellipse(0, 0, enemy.radius * 1.2, enemy.radius * 0.7, 0, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Â∞æ
            const tailLength = enemy.radius * 1.5;
            for (let i = 0; i < 3; i++) {
              const alpha = 0.3 - i * 0.1;
              ctx.strokeStyle = `rgba(52, 152, 219, ${alpha})`;
              ctx.lineWidth = enemy.radius * 0.4 - i * 2;
              ctx.beginPath();
              ctx.moveTo(-enemy.radius, 0);
              ctx.lineTo(-enemy.radius - tailLength + i * 5, 0);
              ctx.stroke();
            }
            break;
            
          case '„Çø„É≥„ÇØ':
            // Á¥´„ÅÆÂÖ≠ËßíÂΩ¢
            ctx.translate(enemy.position.x, enemy.position.y);
            ctx.rotate(time / 2000); // „ÇÜ„Å£„Åè„ÇäÂõûËª¢
            
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Ë£ÖÁî≤„É©„Ç§„É≥
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              const x = Math.cos(angle) * enemy.radius * 0.5;
              const y = Math.sin(angle) * enemy.radius * 0.5;
              ctx.beginPath();
              ctx.arc(x, y, 2, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
            
          case '„Ç∑„É•„Éº„Çø„Éº':
            // „Ç™„É¨„É≥„Ç∏„ÅÆÂÜÜ+Á†≤Ë∫´+ÁÖßÊ∫ñ„Éû„Éº„ÇØ
            ctx.translate(enemy.position.x, enemy.position.y);
            const shooterAngle = Math.atan2(
              enemy.targetY - enemy.position.y,
              enemy.targetX - enemy.position.x
            );
            ctx.rotate(shooterAngle);
            
            // Êú¨‰Ωì
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Á†≤Ë∫´
            ctx.fillStyle = type.secondaryColor;
            ctx.fillRect(0, -enemy.radius * 0.3, enemy.radius * 0.8, enemy.radius * 0.6);
            
            // ÁÖßÊ∫ñ„Éû„Éº„ÇØ
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 1;
            const crosshairSize = 5;
            ctx.beginPath();
            ctx.moveTo(enemy.radius * 0.8 + 5 - crosshairSize, 0);
            ctx.lineTo(enemy.radius * 0.8 + 5 + crosshairSize, 0);
            ctx.moveTo(enemy.radius * 0.8 + 5, -crosshairSize);
            ctx.lineTo(enemy.radius * 0.8 + 5, crosshairSize);
            ctx.stroke();
            break;
            
          case '„ÉÅ„É£„Éº„Ç∏„É£„Éº':
            // Ëµ§„ÅÑ„Éà„Ç≤„Éà„Ç≤ÔºàÁ™ÅÈÄ≤ÊôÇ„Å´ÁôΩ„ÅèÂÖâ„ÇãÔºâ
            ctx.translate(enemy.position.x, enemy.position.y);
            
            const isCharging = enemy.chargeState === 'charging';
            const isPrepping = enemy.chargeState === 'preparing';
            
            // Á™ÅÈÄ≤Ê∫ñÂÇô‰∏≠„ÅØÁÇπÊªÖ
            if (isPrepping) {
              const flash = Math.sin(time / 100) * 0.5 + 0.5;
              ctx.globalAlpha = 0.5 + flash * 0.5;
            }
            
            // „Éà„Ç≤„Éà„Ç≤„ÅÆÂÜÜ
            const spikes = 8;
            ctx.beginPath();
            for (let i = 0; i < spikes * 2; i++) {
              const angle = (Math.PI / spikes) * i;
              const radius = i % 2 === 0 ? enemy.radius * 1.3 : enemy.radius * 0.7;
              const x = Math.cos(angle) * radius;
              const y = Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // Á™ÅÈÄ≤‰∏≠„ÅØÁôΩ„ÅèÂÖâ„Çã
            if (isCharging) {
              ctx.fillStyle = '#ffffff';
              ctx.shadowColor = '#ffffff';
              ctx.shadowBlur = 20;
            } else {
              ctx.fillStyle = type.color;
            }
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            break;
            
          case '„Éá„Éê„ÉïÊïµ':
            // Á¥´„ÅÆÂÜÜ+Ê≥¢Á¥ã„Ç®„Éï„Çß„ÇØ„Éà
            ctx.translate(enemy.position.x, enemy.position.y);
            
            // Ê≥¢Á¥ã„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            const rippleTime = (time / 1000) % 1;
            for (let i = 0; i < 3; i++) {
              const rippleRadius = enemy.radius + (rippleTime + i * 0.33) * type.debuffRange;
              const rippleAlpha = Math.max(0, 0.3 - (rippleTime + i * 0.33) * 0.3);
              
              ctx.strokeStyle = `rgba(155, 89, 182, ${rippleAlpha})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Êú¨‰Ωì
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius, 0, Math.PI * 2);
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // „Éâ„ÇØ„É≠„Éû„Éº„ÇØÈ¢®
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(-enemy.radius * 0.3, -enemy.radius * 0.2, enemy.radius * 0.2, 0, Math.PI * 2);
            ctx.arc(enemy.radius * 0.3, -enemy.radius * 0.2, enemy.radius * 0.2, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case '„Çπ„Éó„É™„ÉÉ„Çø„Éº':
            // Á∑ë„ÅÆÁ¥∞ËÉûÂûã+‰∏≠ÂøÉ„Å´Ê†∏+ÂàÜË£ÇÁ∑ö
            ctx.translate(enemy.position.x, enemy.position.y);
            
            // Á¥∞ËÉûËÜúÔºà„Å∑„Çà„Å∑„ÇàÔºâ
            const wobble = Math.sin(time / 200) * 0.1 + 1;
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
              const angle = (Math.PI * 2 / 16) * i;
              const radiusVar = enemy.radius * wobble * (0.9 + Math.sin(angle * 3 + time / 300) * 0.1);
              const x = Math.cos(angle) * radiusVar;
              const y = Math.sin(angle) * radiusVar;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ‰∏≠ÂøÉ„ÅÆÊ†∏
            ctx.fillStyle = type.secondaryColor;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // ÂàÜË£ÇÁ∑ö
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-enemy.radius, 0);
            ctx.lineTo(enemy.radius, 0);
            ctx.moveTo(0, -enemy.radius);
            ctx.lineTo(0, enemy.radius);
            ctx.stroke();
            break;
            
          case '‰∏≠„Éú„Çπ':
            // ÂõûËª¢„Åô„Çã‰∫îËßíÂΩ¢+„Ç™„Éº„É©
            ctx.translate(enemy.position.x, enemy.position.y);
            const bossRotation = time / 1000;
            ctx.rotate(bossRotation);
            
            // „Ç™„Éº„É©
            ctx.shadowColor = type.color;
            ctx.shadowBlur = 20;
            ctx.strokeStyle = type.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, enemy.radius + 8, 0, Math.PI * 2);
            ctx.stroke();
            
            // Êú¨‰ΩìÔºà‰∫îËßíÂΩ¢Ôºâ
            ctx.shadowBlur = 0;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
              const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = type.color;
            ctx.fill();
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // ÁéãÂÜ†„Éû„Éº„ÇØ
            ctx.fillStyle = '#ffd700';
            ctx.font = `${enemy.radius}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üëë', 0, 0);
            break;
            
          case 'ÊúÄÁµÇ„Éú„Çπ':
            // Â∑®Â§ß„ÅßÂ®ÅÂúßÊÑü„ÅÆ„ÅÇ„ÇãÊúÄÁµÇ„Éú„Çπ
            ctx.translate(enemy.position.x, enemy.position.y);
            const finalBossRotation = time / 800;
            ctx.rotate(finalBossRotation);
            
            // Â§öÈáç„Ç™„Éº„É©„Ç®„Éï„Çß„ÇØ„Éà
            for (let i = 0; i < 3; i++) {
              const auraRadius = enemy.radius + 12 + i * 8;
              const auraAlpha = 0.3 - i * 0.1;
              ctx.strokeStyle = `rgba(255, 0, 0, ${auraAlpha})`;
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // ÁÇé„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 30;
            
            // Êú¨‰ΩìÔºàÂÖ´ËßíÂΩ¢Ôºâ
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
              const angle = (Math.PI * 2 / 8) * i - Math.PI / 2;
              const x = Math.cos(angle) * enemy.radius;
              const y = Math.sin(angle) * enemy.radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            
            // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.radius);
            gradient.addColorStop(0, '#ff6600');
            gradient.addColorStop(0.5, '#ff0000');
            gradient.addColorStop(1, '#cc0000');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = type.secondaryColor;
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // ÁÇé„Éû„Éº„ÇØ
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffff00';
            ctx.font = `${enemy.radius * 1.2}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üî•', 0, 0);
            
            // Âë®Âõ≤„Å´ÂõûËª¢„Åô„ÇãÁÇé
            for (let i = 0; i < 6; i++) {
              const flameAngle = finalBossRotation * 2 + (i * Math.PI / 3);
              const flameDist = enemy.radius + 15;
              const flameX = Math.cos(flameAngle) * flameDist;
              const flameY = Math.sin(flameAngle) * flameDist;
              
              ctx.font = '16px Arial';
              ctx.fillText('üî•', flameX, flameY);
            }
            break;
        }

        ctx.restore();
        
        // HP„Éê„ÉºÔºà„Çø„É≥„ÇØ„ÄÅ‰∏≠„Éú„Çπ„ÄÅ„Çπ„Éó„É™„ÉÉ„Çø„Éº„ÄÅÊúÄÁµÇ„Éú„Çπ„ÅÆ„ÅøÔºâ
        if (type.name === '„Çø„É≥„ÇØ' || type.name === '‰∏≠„Éú„Çπ' || type.name === '„Çπ„Éó„É™„ÉÉ„Çø„Éº' || type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
          ctx.save();
          const barWidth = enemy.radius * 2;
          const barHeight = type.name === 'ÊúÄÁµÇ„Éú„Çπ' ? 6 : 4;
          const barX = enemy.position.x - enemy.radius;
          const barY = enemy.position.y - enemy.radius - (type.name === 'ÊúÄÁµÇ„Éú„Çπ' ? 15 : 10);
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          const hpPercent = enemy.hp / enemy.maxHp;
          ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
          ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
          ctx.restore();
        }
      }

      function drawItem(ctx, item) {
        ctx.save();
        
        const pulse = Math.sin(performance.now() / 200) * 0.2 + 1;
        const radius = item.radius * pulse;
        
        ctx.shadowColor = item.color;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(item.position.x, item.position.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = item.color;
        ctx.fill();
        
        ctx.font = `${radius * 1.5}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.emoji, item.position.x, item.position.y);
        
        ctx.restore();
      }

      function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      // „Éó„É¨„Ç§„É§„Éº„ÅÆ„É¨„Éô„É´„Å´Âøú„Åò„Å¶Âá∫ÁèæÂèØËÉΩ„Å™Êïµ„Çø„Ç§„Éó„ÇíÈÅ∏ÊäûÔºàÈáç„Åø‰ªò„ÅçÔºâ
      function getRandomEnemyType(playerLevel) {
        const availableTypes = Object.values(ENEMY_TYPES).filter(t => 
          t.spawnWeight > 0 && t.minLevel <= playerLevel
        );
        
        if (availableTypes.length === 0) {
          return ENEMY_TYPES.BASIC;
        }
        
        const totalWeight = availableTypes.reduce((sum, t) => sum + t.spawnWeight, 0);
        let random = Math.random() * totalWeight;
        
        for (const type of availableTypes) {
          random -= type.spawnWeight;
          if (random <= 0) {
            return type;
          }
        }
        
        return availableTypes[0];
      }

      // Web Audio API „Çí‰Ωø„Å£„ÅüËªΩÈáè„Ç™„Éº„Éá„Ç£„Ç™„Éû„Éç„Éº„Ç∏„É£„Éº
      class AudioManager {
        constructor() {
          this.audioContext = null;
          this.bgmBuffers = {}; // „Éá„Ç≥„Éº„ÉâÊ∏à„Åø„Éê„ÉÉ„Éï„Ç°„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
          this.sfxBuffers = {}; // ÂäπÊûúÈü≥„Éê„ÉÉ„Éï„Ç°„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•
          this.currentBGM = null; // ÁèæÂú®ÂÜçÁîü‰∏≠„ÅÆBGM„ÇΩ„Éº„Çπ
          this.bgmGainNode = null; // BGMÈü≥Èáè„Ç≥„É≥„Éà„É≠„Éº„É´
          this.sfxGainNode = null; // ÂäπÊûúÈü≥Èü≥Èáè„Ç≥„É≥„Éà„É≠„Éº„É´
          this.isInitialized = false;
          this.isPreloading = false;
          this.preloadProgress = 0;
        }

        // AudioContext„ÇíÂàùÊúüÂåñÔºà„É¶„Éº„Ç∂„ÉºÊìç‰ΩúÂæå„Å´Âëº„Å∂Ôºâ
        async init() {
          if (this.isInitialized) return;

          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // „Ç≤„Ç§„É≥„Éé„Éº„Éâ„Çí‰ΩúÊàê
            this.bgmGainNode = this.audioContext.createGain();
            this.bgmGainNode.connect(this.audioContext.destination);
            
            this.sfxGainNode = this.audioContext.createGain();
            this.sfxGainNode.connect(this.audioContext.destination);
            
            // iOS/AndroidÂØæÂøú: „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çíresume„Åô„Çã
            if (this.audioContext.state === 'suspended') {
              await this.audioContext.resume();
            }
            
            this.isInitialized = true;
            console.log('üéµ AudioContext initialized');
          } catch (error) {
            console.error('AudioContext initialization failed:', error);
          }
        }

        // Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÇíÈùûÂêåÊúü„Éó„É™„É≠„Éº„Éâ
        async preloadAudio(name, url, type = 'bgm') {
          if (!this.isInitialized) {
            console.warn('AudioContext not initialized');
            return;
          }

          try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            
            if (type === 'bgm') {
              this.bgmBuffers[name] = audioBuffer;
            } else {
              this.sfxBuffers[name] = audioBuffer;
            }
            
            console.log(`‚úÖ Loaded: ${name}`);
          } catch (error) {
            console.error(`Failed to load ${name}:`, error);
          }
        }

        // Ë§áÊï∞„ÅÆÈü≥Â£∞„Çí„Åæ„Å®„ÇÅ„Å¶„Éó„É™„É≠„Éº„Éâ
        async preloadAll(bgmList, sfxList) {
          if (!this.isInitialized) {
            await this.init();
          }

          this.isPreloading = true;
          const totalFiles = bgmList.length + sfxList.length;
          let loadedFiles = 0;

          const updateProgress = () => {
            loadedFiles++;
            this.preloadProgress = (loadedFiles / totalFiles) * 100;
          };

          const bgmPromises = bgmList.map(item => 
            this.preloadAudio(item.name, item.url, 'bgm').then(updateProgress)
          );
          
          const sfxPromises = sfxList.map(item => 
            this.preloadAudio(item.name, item.url, 'sfx').then(updateProgress)
          );

          await Promise.all([...bgmPromises, ...sfxPromises]);
          
          this.isPreloading = false;
          console.log('üéâ All audio files loaded!');
        }

        // BGM„ÇíÂÜçÁîüÔºà„É´„Éº„ÉóÂØæÂøúÔºâ
        playBGM(name, volume = 0.5) {
          if (!this.isInitialized || !this.bgmBuffers[name]) {
            console.warn(`BGM ${name} not loaded`);
            return;
          }

          // ÁèæÂú®„ÅÆBGM„ÇíÂÅúÊ≠¢
          this.stopBGM();

          try {
            // Êñ∞„Åó„ÅÑ„ÇΩ„Éº„Çπ„Çí‰ΩúÊàê
            const source = this.audioContext.createBufferSource();
            source.buffer = this.bgmBuffers[name];
            source.loop = true; // „É´„Éº„ÉóÂÜçÁîü
            source.connect(this.bgmGainNode);
            
            // Èü≥ÈáèË®≠ÂÆö
            this.bgmGainNode.gain.value = volume;
            
            // ÂÜçÁîüÈñãÂßã
            source.start(0);
            
            this.currentBGM = source;
            console.log(`üéµ Playing BGM: ${name}`);
          } catch (error) {
            console.error(`Failed to play BGM ${name}:`, error);
          }
        }

        // BGM„ÇíÂÅúÊ≠¢
        stopBGM() {
          if (this.currentBGM) {
            try {
              this.currentBGM.stop();
              this.currentBGM.disconnect();
            } catch (error) {
              // „Åô„Åß„Å´ÂÅúÊ≠¢„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„Ç®„É©„Éº„ÇíÁÑ°Ë¶ñ
            }
            this.currentBGM = null;
          }
        }

        // ÂäπÊûúÈü≥„ÇíÂÜçÁîüÔºàÂêåÊôÇÂÜçÁîüÂèØËÉΩÔºâ
        playSFX(name, volume = 0.5) {
          if (!this.isInitialized || !this.sfxBuffers[name]) {
            console.warn(`SFX ${name} not loaded`);
            return;
          }

          try {
            const source = this.audioContext.createBufferSource();
            source.buffer = this.sfxBuffers[name];
            source.connect(this.sfxGainNode);
            
            // Èü≥ÈáèË®≠ÂÆö
            this.sfxGainNode.gain.value = volume;
            
            // ÂÜçÁîüÈñãÂßãÔºà„É´„Éº„Éó„Å™„ÅóÔºâ
            source.start(0);
            
            // ÂÜçÁîüÁµÇ‰∫ÜÂæå„Å´Ëá™ÂãïÁöÑ„Å´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            source.onended = () => {
              source.disconnect();
            };
          } catch (error) {
            console.error(`Failed to play SFX ${name}:`, error);
          }
        }

        // BGMÈü≥Èáè„ÇíÂ§âÊõ¥
        setBGMVolume(volume) {
          if (this.bgmGainNode) {
            this.bgmGainNode.gain.value = volume;
          }
        }

        // ÂäπÊûúÈü≥Èü≥Èáè„ÇíÂ§âÊõ¥
        setSFXVolume(volume) {
          if (this.sfxGainNode) {
            this.sfxGainNode.gain.value = volume;
          }
        }

        // AudioContext„ÅÆ„Çπ„ÉÜ„Éº„Éà„ÇíÁ¢∫Ë™ç
        getState() {
          return this.audioContext ? this.audioContext.state : 'not initialized';
        }
      }

      class Game {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.isRunning = false;
          this.isPaused = false;
          this.isGameOver = false;
          this.lastTime = 0;
          this.gameTime = 0;
          
          // „Éá„Éê„Ç§„ÇπÂà§ÂÆö(„Çπ„Éû„Éõ„ÅØË∂ÖËªΩÈáèÁâà„ÄÅ„Çø„Éñ„É¨„ÉÉ„Éà„ÅØËªΩÈáèÁâà)
          this.isMobile = window.innerWidth <= 600;
          this.isTablet = window.innerWidth > 600 && window.innerWidth <= 820;
          this.isUltraLowSpec = this.isMobile; // „Çπ„Éû„ÉõÂ∞ÇÁî®Ë∂ÖËªΩÈáè„É¢„Éº„Éâ
          this.isLowSpec = this.isMobile || this.isTablet; // ÂæìÊù•„ÅÆËªΩÈáè„É¢„Éº„Éâ

          this.playerImage = new Image();
          this.playerImage.src = 'images/cosmo-napolitan.png';
          this.playerImageLoaded = false;
          
          // „Éó„É¨„Ç§„É§„ÉºÁîªÂÉè„ÅÆË™≠„ÅøËæº„ÅøÂÆå‰∫Ü„ÇíÂæÖ„Å§
          this.playerImage.onload = () => {
            this.playerImageLoaded = true;
            console.log('‚úÖ Player image loaded');
          };
          
          this.playerImage.onerror = () => {
            console.error('‚ùå Failed to load player image');
            this.playerImageLoaded = true; // „Ç®„É©„Éº„Åß„ÇÇÈÄ≤„ÇÅ„Çã
          };

          this.player = {
            position: { x: canvas.width / 2, y: canvas.height / 2 },
            velocity: { x: 0, y: 0 },
            radius: this.isUltraLowSpec ? 28 : (this.isLowSpec ? 22 : 16), // „Çπ„Éû„Éõ1.75ÂÄç„ÄÅ„Çø„Éñ„É¨„ÉÉ„Éà1.375ÂÄç
            speed: 150,
            hp: 100,
            maxHp: 100,
            xp: 0,
            xpToNextLevel: 10,
            level: 1,
            damage: 15,
            attackSpeed: 1.0,
            projectileSpeed: 300,
            projectileSize: 1.0,
            piercing: 0,
            range: 250,
            shield: 0,
            lastDamageTime: 0, // ÊúÄÂæå„Å´„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÊôÇÂàª
            damageCooldown: 500, // „ÉÄ„É°„Éº„Ç∏„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Ôºà„Éü„É™ÁßíÔºâ
            projectileCount: 1, // ÂêåÊôÇ„Å´Áô∫Â∞Ñ„Åô„ÇãÂºæÊï∞
            invincibleUntil: 0, // ÁÑ°ÊïµÊôÇÈñì„ÅÆÁµÇ‰∫ÜÊôÇÂàª
          };

          this.keys = {};
          this.mouseTarget = null; // „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅÆÁõÆÊ®ôÂú∞ÁÇπ
          this.enemies = [];
          this.projectiles = [];
          this.enemyProjectiles = [];
          this.xpOrbs = [];
          this.items = [];

          this.lastShootTime = 0;
          this.lastEnemySpawnTime = 0;
          // „Çπ„Éû„Éõ„ÅØÊïµ„ÅÆ„Çπ„Éù„Éº„É≥ÈñìÈöî„Çí2ÂÄç„Å´
          this.enemySpawnInterval = this.isUltraLowSpec ? 3000 : 1500;
          this.lastBossLevel = 0; // ÊúÄÂæå„Å´„Éú„Çπ„ÇíÂá∫Áèæ„Åï„Åõ„Åü„É¨„Éô„É´
          this.finalBossSpawned = false; // ÊúÄÁµÇ„Éú„Çπ„ÅåÂá∫Áèæ„Åó„Åü„Åã

          this.stats = {
            enemiesKilled: 0,
            damageDealt: 0,
            timeAlive: 0,
            level: 1,
          };

          // Êñ∞„Åó„ÅÑ„Ç™„Éº„Éá„Ç£„Ç™„Éû„Éç„Éº„Ç∏„É£„Éº„Çí‰ΩøÁî®
          this.audioManager = new AudioManager();
          this.currentBGMName = null;
          
          // „Çµ„Ç¶„É≥„ÉâË®≠ÂÆö
          // „Çπ„Éû„Éõ: BGM OFF„ÄÅÂäπÊûúÈü≥ ON
          // „Çø„Éñ„É¨„ÉÉ„Éà„ÉªPC: „Éá„Éï„Ç©„É´„ÉàOFF(„É¶„Éº„Ç∂„Éº„ÅåÈÅ∏Êäû)
          this.bgmEnabled = !this.isLowSpec; // „Çπ„Éû„Éõ„Éª„Çø„Éñ„É¨„ÉÉ„Éà„Åß„ÅØBGM OFF
          this.sfxEnabled = this.isUltraLowSpec ? true : !this.isLowSpec; // „Çπ„Éû„Éõ„ÅØÂäπÊûúÈü≥ON„ÄÅ„Çø„Éñ„É¨„ÉÉ„Éà„ÅØOFF
          
          // Èü≥Â£∞„Éï„Ç°„Ç§„É´„ÅÆ„É™„Çπ„Éà
          this.bgmList = this.isUltraLowSpec ? [] : [
            { name: 'title', url: 'audio/title_bgm.mp3' },
            { name: 'normal', url: 'audio/normal_bgm.mp3' },
            // „Çø„Éñ„É¨„ÉÉ„ÉàÔºàisLowSpecÔºâ‰ª•Â§ñ„ÅÆ„ÅøËøΩÂä†„ÅÆBGM„ÇíË™≠„ÅøËæº„ÇÄ
            ...(this.isLowSpec && !this.isUltraLowSpec ? [] : [
              { name: 'miniboss', url: 'audio/miniboss_bgm.mp3' },
              { name: 'finalboss', url: 'audio/finalboss_bgm.mp3' },
              { name: 'clear', url: 'audio/clear_bgm.mp3' },
              { name: 'gameover', url: 'audio/gameover_bgm.mp3' }
            ])
          ];
          
          // ÂäπÊûúÈü≥„ÅØÊúÄÂ∞èÈôê„ÅÆ„ÅøÂÖàË™≠„Åø
          this.sfxList = [
            { name: 'playerHit', url: 'audio/player_damage.mp3' },
            { name: 'gemGet', url: 'audio/gem_get.mp3' },
            // „Çø„Éñ„É¨„ÉÉ„ÉàÔºàisLowSpecÔºâ‰ª•Â§ñ„ÅÆ„ÅøËøΩÂä†„ÅÆÂäπÊûúÈü≥„ÇíË™≠„ÅøËæº„ÇÄ
            ...(this.isLowSpec && !this.isUltraLowSpec ? [] : [
              { name: 'enemyHit', url: 'audio/enemy_hit.mp3' },
              { name: 'enemyDeath', url: 'audio/enemy_death.mp3' },
              { name: 'bossDeath', url: 'audio/boss_death.mp3' },
              { name: 'itemGet', url: 'audio/item_get.mp3' }
            ])
          ];


          this.activeEffects = {
            speedBoost: 0,
            powerUp: 0,
            timeSlow: 0,
            invincible: 0,
            magnet: 0,
          };

          this.itemNotification = null;
          this.itemNotificationTime = 0;

          this.setupUI();
          this.setupEventListeners();
        }

        setupUI() {
          this.hpFill = document.getElementById('hp-fill');
          this.hpText = document.getElementById('hp-text');
          this.xpFill = document.getElementById('xp-fill');
          this.xpText = document.getElementById('xp-text');
          this.levelText = document.getElementById('level-text');
          this.timeText = document.getElementById('time-text');
          this.buffsFill = document.getElementById('buffs');
          
          this.startModal = document.getElementById('start-modal');
          this.levelupModal = document.getElementById('levelup-modal');
          this.pauseModal = document.getElementById('pause-modal');
          this.gameoverModal = document.getElementById('gameover-modal');
          this.gameclearModal = document.getElementById('gameclear-modal');
          this.upgradeOptions = document.getElementById('upgrade-options');
          
          // „Çπ„Éû„Éõ„ÅÆÂ†¥Âêà„ÄÅÈü≥Ê•ΩÈÅ∏Êäû„Éú„Çø„É≥„ÇíÈùûÊ¥ªÊÄß„Å´„Åó„Å¶„Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÅÆ„ÅøË°®Á§∫
          if (this.isUltraLowSpec) {
            const musicSelection = document.getElementById('music-selection');
            const musicOnBtn = document.getElementById('music-on-btn');
            const musicOffBtn = document.getElementById('music-off-btn');
            const startBtn = document.getElementById('start-btn');
            
            // Èü≥Ê•ΩÈÅ∏Êäû„Éú„Çø„É≥„ÇíÈùûÊ¥ªÊÄßÂåñÔºàÈùûË°®Á§∫„Å´„Åõ„Åö„ÄÅ„Ç∞„É¨„Éº„Ç¢„Ç¶„ÉàÔºâ
            if (musicOnBtn) {
              musicOnBtn.disabled = true;
              musicOnBtn.style.opacity = '0.5';
              musicOnBtn.style.cursor = 'not-allowed';
            }
            if (musicOffBtn) {
              musicOffBtn.disabled = true;
              musicOffBtn.style.opacity = '0.5';
              musicOffBtn.style.cursor = 'not-allowed';
            }
            
            // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíË°®Á§∫
            if (startBtn) startBtn.style.display = 'inline-block';
            
            // BGM„ÉªÂäπÊûúÈü≥„Éà„Ç∞„É´„ÇíÈùûÊ¥ªÊÄßÂåñ
            const bgmToggle = document.getElementById('bgm-toggle');
            const sfxToggle = document.getElementById('sfx-toggle');
            const soundSettings = document.querySelectorAll('.sound-setting');
            
            if (bgmToggle) {
              bgmToggle.classList.add('disabled');
              bgmToggle.classList.remove('active');
            }
            if (sfxToggle) {
              sfxToggle.classList.add('disabled');
              sfxToggle.classList.remove('active');
            }
            soundSettings.forEach(setting => {
              setting.classList.add('disabled');
            });
          }
          this.buffsContainer = document.getElementById('buffs');

          this.pauseBtn = document.getElementById('pause-btn');
        }

        setupEventListeners() {
          const musicOnBtn = document.getElementById('music-on-btn');
          const musicOffBtn = document.getElementById('music-off-btn');
          const startBtn = document.getElementById('start-btn');

          // Èü≥Ê•Ω„ÅÇ„Çä„Éú„Çø„É≥
          musicOnBtn.addEventListener('click', async () => {
            this.bgmEnabled = true;
            this.sfxEnabled = true; // ÂäπÊûúÈü≥„ÇÇON„Å´
            document.getElementById('bgm-toggle').classList.add('active');
            document.getElementById('sfx-toggle').classList.add('active'); // ÂäπÊûúÈü≥„Éà„Ç∞„É´„ÇÇON„Å´
            
            // „Éú„Çø„É≥„ÅÆ„Éè„Ç§„É©„Ç§„Éà
            musicOnBtn.classList.add('btn-selected');
            musicOffBtn.classList.remove('btn-selected');
            
            // „Éú„Çø„É≥„ÇíÁÑ°ÂäπÂåñÔºà„É≠„Éº„Éâ‰∏≠Ôºâ
            musicOnBtn.disabled = true;
            musicOnBtn.textContent = 'üîä Ë™≠„ÅøËæº„Åø‰∏≠...';
            
            try {
              // AudioManager„ÇíÂàùÊúüÂåñ„Åó„Å¶„Éó„É™„É≠„Éº„Éâ
              console.log('üéµ Initializing AudioManager...');
              await this.audioManager.init();
              console.log('‚úÖ AudioManager initialized');
              
              console.log('üì• Preloading audio files...');
              await this.audioManager.preloadAll(this.bgmList, this.sfxList);
              console.log('‚úÖ All audio files loaded');
              
              // „Çø„Ç§„Éà„É´BGM„ÇíÂÜçÁîü
              console.log('‚ñ∂Ô∏è Playing title BGM...');
              this.playBGM('title');
              
              // „Éú„Çø„É≥„ÇíÂÖÉ„Å´Êàª„Åô
              musicOnBtn.disabled = false;
              musicOnBtn.textContent = 'üîä Èü≥Ê•Ω„ÅÇ„Çä';
              
              // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíË°®Á§∫
              startBtn.style.display = 'inline-block';
            } catch (error) {
              console.error('‚ùå Audio initialization failed:', error);
              alert('Èü≥Ê•Ω„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÈü≥Ê•Ω„Å™„Åó„ÅßÁ∂öË°å„Åó„Åæ„Åô„ÄÇ\n„Ç®„É©„Éº: ' + error.message);
              
              // „Ç®„É©„ÉºÊôÇ„ÅÆÂá¶ÁêÜ
              this.bgmEnabled = false;
              musicOnBtn.disabled = false;
              musicOnBtn.textContent = 'üîä Èü≥Ê•Ω„ÅÇ„Çä';
              startBtn.style.display = 'inline-block';
            }
          });

          // Èü≥Ê•Ω„Å™„Åó„Éú„Çø„É≥
          musicOffBtn.addEventListener('click', async () => {
            this.bgmEnabled = false;
            this.sfxEnabled = false; // ÂäπÊûúÈü≥„ÇÇOFF„Å´
            document.getElementById('bgm-toggle').classList.remove('active');
            document.getElementById('sfx-toggle').classList.remove('active'); // ÂäπÊûúÈü≥„Éà„Ç∞„É´„ÇÇOFF„Å´
            
            // „Éú„Çø„É≥„ÅÆ„Éè„Ç§„É©„Ç§„Éà
            musicOffBtn.classList.add('btn-selected');
            musicOnBtn.classList.remove('btn-selected');
            
            // Èü≥Ê•Ω„Å™„Åó„ÅÆÂ†¥Âêà„ÇÇ„ÄÅÂäπÊûúÈü≥„ÅÆ„Åü„ÇÅ„Å´AudioManager„ÇíÂàùÊúüÂåñ
            if (!this.audioManager.isInitialized) {
              musicOffBtn.disabled = true;
              musicOffBtn.textContent = 'üîá Ë™≠„ÅøËæº„Åø‰∏≠...';
              
              await this.audioManager.init();
              await this.audioManager.preloadAll([], this.sfxList); // ÂäπÊûúÈü≥„ÅÆ„Åø„É≠„Éº„Éâ
              
              musicOffBtn.disabled = false;
              musicOffBtn.textContent = 'üîá Èü≥Ê•Ω„Å™„Åó';
            }
            
            // BGM„ÇíÂÅúÊ≠¢
            this.stopBGM();
            
            // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÇíË°®Á§∫
            startBtn.style.display = 'inline-block';
          });

          // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥
          startBtn.addEventListener('click', async () => {
            // „Éó„É¨„Ç§„É§„ÉºÁîªÂÉè„ÅÆË™≠„ÅøËæº„Åø„ÇíÂæÖ„Å§
            if (!this.playerImageLoaded) {
              console.log('‚è≥ Waiting for player image to load...');
              await new Promise(resolve => {
                if (this.playerImage.complete) {
                  resolve();
                } else {
                  this.playerImage.onload = () => {
                    this.playerImageLoaded = true;
                    resolve();
                  };
                  // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºà3ÁßíÔºâ
                  setTimeout(resolve, 3000);
                }
              });
            }
            
            this.stopBGM(); // „Çø„Ç§„Éà„É´BGM„ÇíÂÅúÊ≠¢
            this.startModal.classList.add('hidden');
            this.start();
          });

          document.getElementById('restart-btn').addEventListener('click', () => {
            window.location.reload();
          });

          document.getElementById('restart-clear-btn').addEventListener('click', () => {
            window.location.reload();
          });

          document.getElementById('resume-btn').addEventListener('click', () => {
            this.togglePause();
          });

          this.pauseBtn.addEventListener('click', () => {
            this.togglePause();
          });

          document.addEventListener('keydown', (e) => {
            this.keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'p' && this.isRunning && !this.isGameOver) {
              this.togglePause();
            }
          });

          document.addEventListener('keyup', (e) => {
            this.keys[e.key.toLowerCase()] = false;
          });

          // „Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ„ÅßÁßªÂãï
          this.canvas.addEventListener('mousedown', (e) => {
            if (this.isPaused || this.isGameOver) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            this.mouseTarget = {
              x: (e.clientX - rect.left) * scaleX,
              y: (e.clientY - rect.top) * scaleY
            };
          });

          // „Éû„Ç¶„ÇπÁßªÂãï‰∏≠„ÇÇÁõÆÊ®ôÂú∞ÁÇπ„ÇíÊõ¥Êñ∞Ôºà„Éâ„É©„ÉÉ„Ç∞ÂØæÂøúÔºâ
          this.canvas.addEventListener('mousemove', (e) => {
            if (this.isPaused || this.isGameOver) return;
            if (e.buttons !== 1) return; // Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰∏≠„ÅÆ„Åø
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            this.mouseTarget = {
              x: (e.clientX - rect.left) * scaleX,
              y: (e.clientY - rect.top) * scaleY
            };
          });

          // „Éû„Ç¶„Çπ„ÇíÈõ¢„Åó„Åü„ÇâÁßªÂãïÂÅúÊ≠¢
          this.canvas.addEventListener('mouseup', () => {
            this.mouseTarget = null;
          });

          // „Çø„ÉÉ„ÉÅÊìç‰ΩúÂØæÂøú
          this.canvas.addEventListener('touchstart', (e) => {
            if (this.isPaused || this.isGameOver) return;
            e.preventDefault();
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            
            this.mouseTarget = {
              x: (touch.clientX - rect.left) * scaleX,
              y: (touch.clientY - rect.top) * scaleY
            };
          });

          this.canvas.addEventListener('touchmove', (e) => {
            if (this.isPaused || this.isGameOver) return;
            e.preventDefault();
            
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            
            this.mouseTarget = {
              x: (touch.clientX - rect.left) * scaleX,
              y: (touch.clientY - rect.top) * scaleY
            };
          });

          this.canvas.addEventListener('touchend', () => {
            this.mouseTarget = null;
          });


          // „Ç≤„Éº„É†ÁµÇ‰∫Ü„Éú„Çø„É≥
          document.getElementById('quit-btn').addEventListener('click', () => {
            if (confirm('Êú¨ÂΩì„Å´„Ç≤„Éº„É†„ÇíÁµÇ‰∫Ü„Åó„Åæ„Åô„ÅãÔºü')) {
              this.quitGame();
            }
          });

          // BGM„Éà„Ç∞„É´
          document.getElementById('bgm-toggle').addEventListener('click', (e) => {
            // „Çπ„Éû„Éõ„ÅÆÂ†¥Âêà„ÅØÁÑ°Âäπ
            if (this.isUltraLowSpec) return;
            
            this.bgmEnabled = !this.bgmEnabled;
            e.currentTarget.classList.toggle('active', this.bgmEnabled);
            
            if (this.bgmEnabled && !this.isPaused) {
              this.playBGM(this.currentBGMName || 'normal');
            } else {
              this.stopBGM();
            }
          });

          // ÂäπÊûúÈü≥„Éà„Ç∞„É´
          document.getElementById('sfx-toggle').addEventListener('click', (e) => {
            // „Çπ„Éû„Éõ„ÅÆÂ†¥Âêà„ÅØÁÑ°Âäπ
            if (this.isUltraLowSpec) return;
            
            this.sfxEnabled = !this.sfxEnabled;
            e.currentTarget.classList.toggle('active', this.sfxEnabled);
          });
        }

        start() {
          this.isRunning = true;
          this.lastTime = performance.now();
          this.gameLoop(this.lastTime);
          
          // ÈÄöÂ∏∏Êà¶ÈóòBGM„ÇíÂÜçÁîü
          this.playBGM('normal');
        }

        playBGM(type) {
          // „Çµ„Ç¶„É≥„ÉâË®≠ÂÆö„ÅåOFF„ÅÆÂ†¥Âêà„ÅØÂÜçÁîü„Åó„Å™„ÅÑ
          if (!this.bgmEnabled) return;
          
          // ÁèæÂú®„ÅÆ„Çø„Ç§„Éó„Çí‰øùÂ≠ò
          this.currentBGMName = type;
          
          // Èü≥Èáè„Éû„ÉÉ„Éó
          const volumeMap = {
            'title': 0.5,
            'normal': 0.5,
            'miniboss': 0.6,
            'finalboss': 0.7,
            'clear': 0.6,
            'gameover': 0.5
          };
          
          // AudioManager„ÅßÂÜçÁîü
          const volume = volumeMap[type] || 0.5;
          this.audioManager.playBGM(type, volume);
        }

        stopBGM() {
          this.audioManager.stopBGM();
        }

        playSFX(type) {
          // ÂäπÊûúÈü≥Ë®≠ÂÆö„ÅåOFF„ÅÆÂ†¥Âêà„ÅØÂÜçÁîü„Åó„Å™„ÅÑ
          if (!this.sfxEnabled) return;
          
          // Èü≥Èáè„Éû„ÉÉ„Éó
          const volumeMap = {
            'playerHit': 0.6,
            'enemyHit': 0.15,
            'enemyDeath': 0.5,
            'bossDeath': 0.7,
            'gemGet': 0.5,
            'itemGet': 0.6
          };
          
          // AudioManager„ÅßÂÜçÁîü
          const volume = volumeMap[type] || 0.5;
          this.audioManager.playSFX(type, volume);
        }

        togglePause() {
          if (this.isGameOver) return;
          
          this.isPaused = !this.isPaused;
          this.pauseModal.classList.toggle('hidden');
          this.pauseBtn.classList.toggle('paused');
          
          if (this.isPaused) {
            // „Éù„Éº„Ç∫ÊôÇ„ÅØBGM„ÇíÂÅúÊ≠¢
            if (this.bgmEnabled) {
              this.stopBGM();
            }
          } else {
            // ÂÜçÈñãÊôÇ„ÅØBGM„ÇíÂÜçÁîü
            this.lastTime = performance.now();
            if (this.bgmEnabled) {
              this.playBGM(this.currentBGMName || 'normal');
            }
            this.gameLoop(this.lastTime);
          }
        }

        quitGame() {
          this.isGameOver = true;
          this.stopBGM();
          this.pauseModal.classList.add('hidden');
          
          // „Çø„Ç§„Éà„É´ÁîªÈù¢„Å´Êàª„Çã
          window.location.reload();
        }

        gameLoop(currentTime) {
          if (!this.isRunning || this.isPaused) return;

          const deltaTime = (currentTime - this.lastTime) / 1000;
          this.lastTime = currentTime;

          this.update(deltaTime, currentTime);
          this.render();

          if (!this.isGameOver) {
            requestAnimationFrame((time) => this.gameLoop(time));
          }
        }

        update(deltaTime, currentTime) {
          this.gameTime += deltaTime * 1000;
          this.timeText.textContent = formatTime(this.gameTime);

          const timeSlowActive = this.activeEffects.timeSlow > currentTime;
          const effectiveDelta = timeSlowActive ? deltaTime * 0.5 : deltaTime;

          this.updatePlayer(deltaTime);
          this.updateEnemies(effectiveDelta, currentTime);
          this.updateProjectiles(deltaTime);
          this.updateEnemyProjectiles(deltaTime);
          this.updateXPOrbs(deltaTime);
          this.updateItems(deltaTime);
          this.updateEffects(currentTime);
          this.updateBuffsUI();

          this.shoot(currentTime);
          this.spawnEnemies(currentTime);

          this.checkCollisions();
        }

        updatePlayer(deltaTime) {
          let dx = 0;
          let dy = 0;

          // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ
          let keyboardInput = false;
          if (this.keys['w'] || this.keys['arrowup']) { dy -= 1; keyboardInput = true; }
          if (this.keys['s'] || this.keys['arrowdown']) { dy += 1; keyboardInput = true; }
          if (this.keys['a'] || this.keys['arrowleft']) { dx -= 1; keyboardInput = true; }
          if (this.keys['d'] || this.keys['arrowright']) { dx += 1; keyboardInput = true; }

          // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ„Åå„ÅÇ„Å£„Åü„Çâ„Éû„Ç¶„Çπ„Çø„Éº„Ç≤„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢
          if (keyboardInput) {
            this.mouseTarget = null;
          }

          // „Éû„Ç¶„Çπ„Çø„Éº„Ç≤„ÉÉ„Éà„Åå„ÅÇ„ÇãÂ†¥Âêà
          if (!keyboardInput && this.mouseTarget) {
            const targetDx = this.mouseTarget.x - this.player.position.x;
            const targetDy = this.mouseTarget.y - this.player.position.y;
            const distance = Math.sqrt(targetDx * targetDx + targetDy * targetDy);

            // ÁõÆÊ®ôÂú∞ÁÇπ„Å´ÂçÅÂàÜËøë„Å•„ÅÑ„Åü„ÇâÂÅúÊ≠¢
            if (distance < 5) {
              this.mouseTarget = null;
            } else {
              dx = targetDx / distance;
              dy = targetDy / distance;
            }
          }

          if (dx !== 0 || dy !== 0) {
            const length = Math.sqrt(dx * dx + dy * dy);
            dx /= length;
            dy /= length;

            let speedMultiplier = this.activeEffects.speedBoost > performance.now() ? 1.5 : 1.0;
            
            // „Éá„Éê„ÉïÊïµ„ÅÆÁØÑÂõ≤ÂÜÖ„Å´„ÅÑ„ÇãÂ†¥Âêà„ÅØÈÄüÂ∫¶„Çí‰∏ã„Åí„Çã
            if (this.debuffedByEnemy) {
              speedMultiplier *= 0.5;
            }
            
            const speed = this.player.speed * speedMultiplier;

            this.player.position.x += dx * speed * deltaTime;
            this.player.position.y += dy * speed * deltaTime;

            this.player.position.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.position.x));
            this.player.position.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.position.y));
          }
        }

        updateEnemies(deltaTime, currentTime) {
          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            // „ÉÅ„É£„Éº„Ç∏„É£„Éº„ÅÆÁ™ÅÈÄ≤Âá¶ÁêÜ
            if (enemy.type.name === '„ÉÅ„É£„Éº„Ç∏„É£„Éº') {
              if (!enemy.chargeState) {
                enemy.chargeState = 'idle';
                enemy.lastChargeTime = currentTime;
                enemy.chargeDirection = null;
              }

              if (enemy.chargeState === 'idle' && currentTime - enemy.lastChargeTime >= enemy.type.chargeInterval) {
                // Á™ÅÈÄ≤Ê∫ñÂÇôÈñãÂßã
                enemy.chargeState = 'preparing';
                enemy.prepareStartTime = currentTime;
                
                // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆÊñπÂêë„ÇíË®òÈå≤
                const dx = this.player.position.x - enemy.position.x;
                const dy = this.player.position.y - enemy.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                enemy.chargeDirection = { x: dx / distance, y: dy / distance };
              } else if (enemy.chargeState === 'preparing' && currentTime - enemy.prepareStartTime >= 500) {
                // Á™ÅÈÄ≤ÈñãÂßã
                enemy.chargeState = 'charging';
                enemy.chargeStartTime = currentTime;
              } else if (enemy.chargeState === 'charging' && currentTime - enemy.chargeStartTime >= enemy.type.chargeDuration) {
                // Á™ÅÈÄ≤ÁµÇ‰∫Ü
                enemy.chargeState = 'idle';
                enemy.lastChargeTime = currentTime;
                enemy.chargeDirection = null;
              }
            }

            // „Éá„Éê„ÉïÊïµ„ÅÆÁØÑÂõ≤„Éá„Éê„ÉïÂá¶ÁêÜ
            if (enemy.type.name === '„Éá„Éê„ÉïÊïµ') {
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < enemy.type.debuffRange) {
                // „Éó„É¨„Ç§„É§„Éº„ÇíÈÅÖ„Åè„Åô„Çã
                if (!this.debuffedByEnemy) {
                  this.debuffedByEnemy = true;
                }
              }
            }

            // ÁßªÂãïÂá¶ÁêÜ
            let moveSpeed = enemy.speed;
            
            if (enemy.type.name === '„ÉÅ„É£„Éº„Ç∏„É£„Éº' && enemy.chargeState === 'charging' && enemy.chargeDirection) {
              // Á™ÅÈÄ≤‰∏≠„ÅØÈ´òÈÄüÁßªÂãï
              enemy.velocity.x = enemy.chargeDirection.x * enemy.type.chargeSpeed * 50;
              enemy.velocity.y = enemy.chargeDirection.y * enemy.type.chargeSpeed * 50;
            } else if (enemy.type.name === '„ÉÅ„É£„Éº„Ç∏„É£„Éº' && enemy.chargeState === 'preparing') {
              // Ê∫ñÂÇô‰∏≠„ÅØÂÅúÊ≠¢
              enemy.velocity.x = 0;
              enemy.velocity.y = 0;
            } else {
              // ÈÄöÂ∏∏ÁßªÂãï
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance > 0) {
                enemy.velocity.x = (dx / distance) * moveSpeed * 50;
                enemy.velocity.y = (dy / distance) * moveSpeed * 50;
              }
            }

            enemy.position.x += enemy.velocity.x * deltaTime;
            enemy.position.y += enemy.velocity.y * deltaTime;

            // „Ç∑„É•„Éº„Çø„Éº„ÅÆÁÖßÊ∫ñÊõ¥Êñ∞
            if (enemy.type.name === '„Ç∑„É•„Éº„Çø„Éº' || enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
              enemy.targetX = this.player.position.x;
              enemy.targetY = this.player.position.y;
            }

            if (enemy.damageFlash > 0) {
              enemy.damageFlash -= deltaTime * 1000;
            }

            // „Ç∑„É•„Éº„Çø„ÉºÁ≥ª„ÅÆÊïµ„ÅÆÂ∞ÑÊíÉ
            if ((enemy.type.name === '„Ç∑„É•„Éº„Çø„Éº' || enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') && 
                currentTime - enemy.lastShootTime >= enemy.type.shootInterval) {
              this.enemyShoot(enemy);
              enemy.lastShootTime = currentTime;
            }
          });

          // „Éá„Éê„ÉïËß£Èô§„ÉÅ„Çß„ÉÉ„ÇØ
          this.debuffedByEnemy = false;
          this.enemies.forEach(enemy => {
            if (enemy.isAlive && enemy.type.name === '„Éá„Éê„ÉïÊïµ') {
              const dx = this.player.position.x - enemy.position.x;
              const dy = this.player.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < enemy.type.debuffRange) {
                this.debuffedByEnemy = true;
              }
            }
          });

          this.enemies = this.enemies.filter(e => e.isAlive);
        }

        enemyShoot(enemy) {
          const dx = this.player.position.x - enemy.position.x;
          const dy = this.player.position.y - enemy.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance === 0) return;

          const speed = 200;
          this.enemyProjectiles.push({
            position: { x: enemy.position.x, y: enemy.position.y },
            velocity: { x: (dx / distance) * speed, y: (dy / distance) * speed },
            radius: 5,
            damage: enemy.type.damage,
            isAlive: true,
          });
        }

        updateProjectiles(deltaTime) {
          this.projectiles.forEach(proj => {
            if (!proj.isAlive) return;

            proj.position.x += proj.velocity.x * deltaTime;
            proj.position.y += proj.velocity.y * deltaTime;

            if (proj.position.x < 0 || proj.position.x > this.canvas.width ||
                proj.position.y < 0 || proj.position.y > this.canvas.height) {
              proj.isAlive = false;
            }
          });

          this.projectiles = this.projectiles.filter(p => p.isAlive);
        }

        updateEnemyProjectiles(deltaTime) {
          this.enemyProjectiles.forEach(proj => {
            if (!proj.isAlive) return;

            proj.position.x += proj.velocity.x * deltaTime;
            proj.position.y += proj.velocity.y * deltaTime;

            if (proj.position.x < 0 || proj.position.x > this.canvas.width ||
                proj.position.y < 0 || proj.position.y > this.canvas.height) {
              proj.isAlive = false;
            }
          });

          this.enemyProjectiles = this.enemyProjectiles.filter(p => p.isAlive);
        }

        updateXPOrbs(deltaTime) {
          const magnetActive = this.activeEffects.magnet > performance.now();
          const magnetRadius = magnetActive ? 200 : 100;

          this.xpOrbs.forEach(orb => {
            const dx = this.player.position.x - orb.position.x;
            const dy = this.player.position.y - orb.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < magnetRadius) {
              const speed = magnetActive ? 400 : 200;
              orb.position.x += (dx / distance) * speed * deltaTime;
              orb.position.y += (dy / distance) * speed * deltaTime;
            }
          });
        }

        updateItems(deltaTime) {
          this.items.forEach(item => {
            if (!item.isAlive) return;

            item.lifetime += deltaTime * 1000;
            if (item.lifetime > 15000) {
              item.isAlive = false;
            }
          });

          this.items = this.items.filter(i => i.isAlive);
        }

        updateEffects(currentTime) {
          Object.keys(this.activeEffects).forEach(key => {
            if (this.activeEffects[key] > 0 && this.activeEffects[key] < currentTime) {
              this.activeEffects[key] = 0;
            }
          });
        }

        shoot(currentTime) {
          const shootDelay = 1000 / this.player.attackSpeed;

          if (currentTime - this.lastShootTime < shootDelay) return;

          const nearestEnemy = this.findNearestEnemy();
          if (!nearestEnemy) return;

          const dx = nearestEnemy.position.x - this.player.position.x;
          const dy = nearestEnemy.position.y - this.player.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > this.player.range) return;

          const powerUpActive = this.activeEffects.powerUp > currentTime;
          const damageMultiplier = powerUpActive ? 2.0 : 1.0;

          // Ë§áÊï∞„ÅÆÂºæ„ÇíÁô∫Â∞Ñ
          const count = this.player.projectileCount;
          
          for (let i = 0; i < count; i++) {
            let finalAngle;
            
            if (i === 0) {
              // 1Áô∫ÁõÆ„ÅØÊïµ„Å´Âêë„Åã„Å£„Å¶Áô∫Â∞Ñ
              finalAngle = Math.atan2(dy, dx);
            } else {
              // 2Áô∫ÁõÆ‰ª•Èôç„ÅØ„É©„É≥„ÉÄ„É†„Å™ÊñπÂêë
              finalAngle = Math.random() * Math.PI * 2;
            }
            
            this.projectiles.push({
              position: { x: this.player.position.x, y: this.player.position.y },
              velocity: { 
                x: Math.cos(finalAngle) * this.player.projectileSpeed, 
                y: Math.sin(finalAngle) * this.player.projectileSpeed 
              },
              radius: 5 * this.player.projectileSize,
              damage: this.player.damage * damageMultiplier,
              piercing: this.player.piercing,
              isAlive: true,
            });
          }

          this.lastShootTime = currentTime;
        }

        findNearestEnemy() {
          let nearest = null;
          let minDist = Infinity;

          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            const dx = enemy.position.x - this.player.position.x;
            const dy = enemy.position.y - this.player.position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < minDist) {
              minDist = dist;
              nearest = enemy;
            }
          });

          return nearest;
        }

        spawnEnemies(currentTime) {
          // ËªΩÈáèÁâà„Åß„ÅØÊïµ„ÅÆÊúÄÂ§ßÊï∞„ÇíÂà∂Èôê(Â∞ë„ÅóÂ¢ó„ÇÑ„Åó„Åü)
          const maxEnemies = this.isLowSpec ? 25 : 50;
          const activeEnemies = this.enemies.filter(e => e.isAlive).length;
          
          if (activeEnemies >= maxEnemies) {
            return; // Êïµ„ÅåÂ§ö„Åô„Åé„ÇãÂ†¥Âêà„ÅØ„Çπ„Éù„Éº„É≥„Åó„Å™„ÅÑ
          }
          
          if (currentTime - this.lastEnemySpawnTime > this.enemySpawnInterval) {
            // ËªΩÈáèÁâà„Åß„ÇÇÊïµ„ÅÆÊï∞„ÇíÁ¢∫‰øù(„É¨„Éô„É´„Å´Âøú„Åò„Å¶Â¢óÂä†)
            const baseCount = this.isLowSpec 
              ? Math.min(2, 1 + Math.floor(this.gameTime / 60000)) // 1ÂàÜ„Åî„Å®„Å´1‰ΩìÂ¢óÂä†
              : Math.min(3, 1 + Math.floor(this.gameTime / 45000));
            const count = baseCount;
            
            for (let i = 0; i < count; i++) {
              // ÊúÄÂ§ßÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
              if (this.enemies.filter(e => e.isAlive).length >= maxEnemies) {
                break;
              }
              this.spawnEnemy();
            }
            
            this.lastEnemySpawnTime = currentTime;
            // ËªΩÈáèÁâà„Åß„ÇÇÂá∫ÁèæÈñìÈöî„ÇíÂ∞ë„ÅóÁü≠„Åè
            const baseInterval = this.isLowSpec ? 1500 : 1500;
            this.enemySpawnInterval = Math.max(this.isLowSpec ? 1000 : 800, baseInterval - this.gameTime / 150);
          }
        }

        spawnEnemy() {
          const type = getRandomEnemyType(this.player.level);
          const side = Math.floor(Math.random() * 4);
          let x, y;

          switch (side) {
            case 0: x = Math.random() * this.canvas.width; y = -20; break;
            case 1: x = this.canvas.width + 20; y = Math.random() * this.canvas.height; break;
            case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 20; break;
            case 3: x = -20; y = Math.random() * this.canvas.height; break;
          }

          // ËªΩÈáèÁâà„Åß„ÅØÊïµ„ÇíÂº∑Âåñ„Åó„Å¶„Éê„É©„É≥„Çπ„ÇíÂèñ„Çã
          const hpMultiplier = 1.0; // HP„ÅØ‰∏ä„Åí„Å™„ÅÑ
          const speedMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const damageMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const xpMultiplier = this.isLowSpec ? 1.8 : 1.0; // ÁµåÈ®ìÂÄ§„ÇÇÂ¢ó„ÇÑ„Åô

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 15,
            speed: type.speed * speedMultiplier,
            hp: type.hp * hpMultiplier,
            maxHp: type.hp * hpMultiplier,
            damage: type.damage * damageMultiplier,
            xpValue: Math.floor(type.xp * xpMultiplier),
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: type.splitCount || 0,
          });
        }

        spawnMiniBoss() {
          const type = ENEMY_TYPES.MINIBOSS;
          const side = Math.floor(Math.random() * 4);
          let x, y;

          switch (side) {
            case 0: x = this.canvas.width / 2; y = -30; break;
            case 1: x = this.canvas.width + 30; y = this.canvas.height / 2; break;
            case 2: x = this.canvas.width / 2; y = this.canvas.height + 30; break;
            case 3: x = -30; y = this.canvas.height / 2; break;
          }

          // ËªΩÈáèÁâà„Åß„ÅØ‰∏≠„Éú„Çπ„ÇÇÂº∑Âåñ
          const hpMultiplier = 1.0; // HP„ÅØ‰∏ä„Åí„Å™„ÅÑ
          const damageMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const xpMultiplier = this.isLowSpec ? 1.5 : 1.0;

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 30,
            speed: type.speed,
            hp: type.hp * hpMultiplier,
            maxHp: type.hp * hpMultiplier,
            damage: type.damage * damageMultiplier,
            xpValue: Math.floor(type.xp * xpMultiplier),
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: 0,
          });
        }

        spawnFinalBoss() {
          const type = ENEMY_TYPES.FINALBOSS;
          
          // ÁîªÈù¢‰∏≠Â§Æ‰∏ä„Åã„ÇâÁôªÂ†¥
          const x = this.canvas.width / 2;
          const y = -50;

          // ËªΩÈáèÁâà„Åß„ÅØÊúÄÁµÇ„Éú„Çπ„ÇÇÂº∑Âåñ
          const hpMultiplier = 1.0; // HP„ÅØ‰∏ä„Åí„Å™„ÅÑ
          const damageMultiplier = this.isLowSpec ? 1.3 : 1.0;
          const xpMultiplier = this.isLowSpec ? 1.5 : 1.0;

          this.enemies.push({
            type: type,
            position: { x, y },
            velocity: { x: 0, y: 0 },
            radius: 50,
            speed: type.speed,
            hp: type.hp * hpMultiplier,
            maxHp: type.hp * hpMultiplier,
            damage: type.damage * damageMultiplier,
            xpValue: Math.floor(type.xp * xpMultiplier),
            isAlive: true,
            damageFlash: 0,
            lastShootTime: 0,
            targetX: this.player.position.x,
            targetY: this.player.position.y,
            splitCount: 0,
          });
          
          // ÊúÄÁµÇ„Éú„ÇπBGM„Å´Âàá„ÇäÊõø„Åà
          this.playBGM('finalboss');
        }

        checkCollisions() {
          // „Éó„É¨„Ç§„É§„Éº„ÅÆÂºæ„Å®Êïµ
          this.projectiles.forEach(proj => {
            if (!proj.isAlive) return;

            this.enemies.forEach(enemy => {
              if (!enemy.isAlive) return;

              const dx = proj.position.x - enemy.position.x;
              const dy = proj.position.y - enemy.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < proj.radius + enemy.radius) {
                enemy.hp -= proj.damage;
                enemy.damageFlash = 200;
                this.stats.damageDealt += proj.damage;
                
                // Êïµ„Å´ÊîªÊíÉ„ÅåÂΩì„Åü„Å£„ÅüÂäπÊûúÈü≥
                this.playSFX('enemyHit');

                if (proj.piercing > 0) {
                  proj.piercing--;
                } else {
                  proj.isAlive = false;
                }

                if (enemy.hp <= 0) {
                  enemy.isAlive = false;
                  this.stats.enemiesKilled++;
                  
                  // „Éú„ÇπÊíÉÁ†¥„ÅÆÂäπÊûúÈü≥
                  if (enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
                    this.playSFX('bossDeath');
                  } else {
                    // ÈÄöÂ∏∏ÊïµÊíÉÁ†¥„ÅÆÂäπÊûúÈü≥
                    this.playSFX('enemyDeath');
                  }
                  
                  this.spawnXPOrb(enemy.position.x, enemy.position.y, enemy.xpValue, enemy.type.name === '‰∏≠„Éú„Çπ' || enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ');

                  // ÊúÄÁµÇ„Éú„Çπ„ÇíÂÄí„Åó„Åü„Çâ„ÇØ„É™„Ç¢
                  if (enemy.type.name === 'ÊúÄÁµÇ„Éú„Çπ') {
                    this.gameClear();
                    return;
                  }

                  // „Çπ„Éó„É™„ÉÉ„Çø„Éº„ÅØÂÄí„Åô„Å®ÂàÜË£Ç„Åô„Çã
                  if (enemy.type.name === '„Çπ„Éó„É™„ÉÉ„Çø„Éº' && enemy.splitCount && enemy.splitCount > 0) {
                    for (let i = 0; i < enemy.type.splitCount; i++) {
                      const angle = (Math.PI * 2 / enemy.type.splitCount) * i;
                      const offsetX = Math.cos(angle) * 30;
                      const offsetY = Math.sin(angle) * 30;
                      
                      this.enemies.push({
                        type: enemy.type,
                        position: { x: enemy.position.x + offsetX, y: enemy.position.y + offsetY },
                        velocity: { x: 0, y: 0 },
                        radius: enemy.radius * 0.7,
                        speed: enemy.speed * 1.2,
                        hp: enemy.maxHp * 0.5,
                        maxHp: enemy.maxHp * 0.5,
                        damage: enemy.damage * 0.7,
                        xpValue: Math.ceil(enemy.xpValue * 0.5),
                        isAlive: true,
                        damageFlash: 0,
                        lastShootTime: 0,
                        targetX: this.player.position.x,
                        targetY: this.player.position.y,
                        splitCount: 0, // ÂàÜË£ÇÊ∏à„Åø„ÅØ„ÇÇ„ÅÜÂàÜË£Ç„Åó„Å™„ÅÑ
                      });
                    }
                  }

                  if (Math.random() < 0.1) {
                    this.spawnItem(enemy.position.x, enemy.position.y);
                  }
                }
              }
            });
          });

          // Êïµ„ÅÆÂºæ„Å®„Éó„É¨„Ç§„É§„Éº
          this.enemyProjectiles.forEach(proj => {
            if (!proj.isAlive) return;

            const dx = proj.position.x - this.player.position.x;
            const dy = proj.position.y - this.player.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < proj.radius + this.player.radius) {
              proj.isAlive = false;
              this.damagePlayer(proj.damage, performance.now());
            }
          });

          // „Éó„É¨„Ç§„É§„Éº„Å®ÁµåÈ®ìÂÄ§„Ç™„Éº„Éñ
          this.xpOrbs.forEach((orb, index) => {
            const dx = this.player.position.x - orb.position.x;
            const dy = this.player.position.y - orb.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + orb.radius) {
              this.player.xp += orb.value;
              this.xpOrbs.splice(index, 1);
              // „Ç™„Éº„ÉñÂèñÂæóÂäπÊûúÈü≥
              this.playSFX('gemGet');
              this.updateUI();
              this.checkLevelUp();
            }
          });

          // „Éó„É¨„Ç§„É§„Éº„Å®„Ç¢„Ç§„ÉÜ„É†
          this.items.forEach((item, index) => {
            if (!item.isAlive) return;

            const dx = this.player.position.x - item.position.x;
            const dy = this.player.position.y - item.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + item.radius) {
              this.applyItemEffect(item);
              item.isAlive = false;
              // „Ç¢„Ç§„ÉÜ„É†ÂèñÂæóÂäπÊûúÈü≥
              this.playSFX('itemGet');
            }
          });

          // „Éó„É¨„Ç§„É§„Éº„Å®Êïµ„ÅÆÊé•Ëß¶
          this.enemies.forEach(enemy => {
            if (!enemy.isAlive) return;

            const dx = this.player.position.x - enemy.position.x;
            const dy = this.player.position.y - enemy.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.player.radius + enemy.radius) {
              this.damagePlayer(enemy.damage, performance.now());
            }
          });
        }

        damagePlayer(damage, currentTime) {
          // ÁÑ°ÊïµÊôÇÈñì‰∏≠„ÅØ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å™„ÅÑ
          if (this.activeEffects.invincible > currentTime) return;
          
          // „ÉÄ„É°„Éº„Ç∏„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„ÅØ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å™„ÅÑ
          if (currentTime - this.player.lastDamageTime < this.player.damageCooldown) return;

          if (this.player.shield > 0) {
            this.player.shield = Math.max(0, this.player.shield - damage);
            this.player.lastDamageTime = currentTime;
            // „Éó„É¨„Ç§„É§„Éº„ÉÄ„É°„Éº„Ç∏ÂäπÊûúÈü≥
            this.playSFX('playerHit');
            return;
          }

          this.player.hp = Math.max(0, this.player.hp - damage);
          this.player.lastDamageTime = currentTime;
          // „Éó„É¨„Ç§„É§„Éº„ÉÄ„É°„Éº„Ç∏ÂäπÊûúÈü≥
          this.playSFX('playerHit');
          this.updateUI();

          if (this.player.hp <= 0) {
            this.gameOver();
          }
        }

        spawnXPOrb(x, y, value, isBossOrb = false) {
          this.xpOrbs.push({
            position: { x, y },
            radius: isBossOrb ? 12 : 6,
            value: value,
            isBossOrb: isBossOrb,
          });
        }

        spawnItem(x, y) {
          const items = [
            { type: 'heal', emoji: '‚ù§Ô∏è', color: '#ff6b6b', name: 'ÂõûÂæ©' },
            { type: 'speedBoost', emoji: '‚ö°', color: '#feca57', name: '„Çπ„Éî„Éº„Éâ„Éñ„Éº„Çπ„Éà' },
            { type: 'powerUp', emoji: 'üí™', color: '#ff6348', name: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó' },
            { type: 'timeSlow', emoji: 'üåÄ', color: '#5f27cd', name: '„Çø„Ç§„É†„Çπ„É≠„Éº' },
            { type: 'invincible', emoji: '‚ú®', color: '#ff9ff3', name: 'ÁÑ°Êïµ' },
            { type: 'magnet', emoji: 'üéØ', color: '#54a0ff', name: '„Éû„Ç∞„Éç„ÉÉ„Éà' },
          ];

          const item = items[Math.floor(Math.random() * items.length)];
          
          this.items.push({
            ...item,
            position: { x, y },
            radius: 12,
            isAlive: true,
            lifetime: 0,
          });
        }

        applyItemEffect(item) {
          const currentTime = performance.now();
          
          this.itemNotification = item;
          this.itemNotificationTime = currentTime;

          switch (item.type) {
            case 'heal':
              this.player.hp = Math.min(this.player.maxHp, this.player.hp + 30);
              break;
            case 'speedBoost':
              this.activeEffects.speedBoost = currentTime + 5000;
              break;
            case 'powerUp':
              this.activeEffects.powerUp = currentTime + 8000;
              break;
            case 'timeSlow':
              this.activeEffects.timeSlow = currentTime + 5000;
              break;
            case 'invincible':
              this.activeEffects.invincible = currentTime + 3000;
              this.player.invincibleUntil = currentTime + 3000;
              break;
            case 'magnet':
              this.activeEffects.magnet = currentTime + 10000;
              break;
          }

          this.updateUI();
        }

        checkLevelUp() {
          if (this.player.xp >= this.player.xpToNextLevel) {
            this.player.xp -= this.player.xpToNextLevel;
            this.player.level++;
            
            // „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Å´ÂøÖË¶Å„Å™ÁµåÈ®ìÂÄ§„ÅÆÂ¢óÂä†Áéá
            let xpMultiplier = 1.3;
            
            // „Çπ„Éû„Éõ„Éª„Çø„Éñ„É¨„ÉÉ„Éà„Åß„É¨„Éô„É´18‰ª•Èôç„ÅØÂ¢óÂä†Áéá„ÇíÁ∑©Âíå
            if (this.isLowSpec || this.isUltraLowSpec) {
              if (this.player.level >= 18) {
                xpMultiplier = 1.15; // 18„É¨„Éô„É´‰ª•Èôç„ÅØ1.15ÂÄç„Å´
              } else if (this.player.level >= 15) {
                xpMultiplier = 1.2; // 15-17„É¨„Éô„É´„ÅØ1.2ÂÄç„Å´
              }
            }
            
            this.player.xpToNextLevel = Math.floor(this.player.xpToNextLevel * xpMultiplier);
            
            // „É¨„Éô„É´10‰ª•Èôç„ÅØ‰∏≠„Éú„Çπ„ÅÆÂá∫ÁèæÈ†ªÂ∫¶„Çí‰∏ä„Åí„Çã
            let miniBossInterval = 5; // Âü∫Êú¨„ÅØ5„É¨„Éô„É´„Åî„Å®
            if (this.player.level >= 10) {
              miniBossInterval = this.isLowSpec ? 2 : 3; // ËªΩÈáèÁâà„ÅØ2„É¨„Éô„É´„Åî„Å®„ÄÅÈÄöÂ∏∏Áâà„ÅØ3„É¨„Éô„É´„Åî„Å®
            }
            
            // ‰∏≠„Éú„ÇπÂá∫Áèæ
            if (this.player.level % miniBossInterval === 0 && this.player.level < 20 && this.player.level > this.lastBossLevel) {
              this.spawnMiniBoss();
              this.lastBossLevel = this.player.level;
            }
            
            // „É¨„Éô„É´20„ÅßÊúÄÁµÇ„Éú„ÇπÂá∫Áèæ
            if (this.player.level === 20 && !this.finalBossSpawned) {
              this.spawnFinalBoss();
              this.finalBossSpawned = true;
            }
            
            this.isPaused = true;
            this.showLevelUpModal();
            this.updateUI();
          }
        }

        showLevelUpModal() {
          const upgrades = [
            { 
              id: 'damage', 
              name: '‚ú® ÊîªÊíÉÂäõ„Ç¢„ÉÉ„Éó', 
              description: '„ÉÄ„É°„Éº„Ç∏„Åå20%Â¢óÂä†',
              apply: () => this.player.damage *= 1.20
            },
            { 
              id: 'attackSpeed', 
              name: '‚ö° ÊîªÊíÉÈÄüÂ∫¶„Ç¢„ÉÉ„Éó', 
              description: 'ÊîªÊíÉÈñìÈöî„ÅåÁü≠„Åè„Å™„ÇãÔºà20%UPÔºâ',
              apply: () => this.player.attackSpeed *= 1.2
            },
            { 
              id: 'speed', 
              name: 'üèÉ ÁßªÂãïÈÄüÂ∫¶„Ç¢„ÉÉ„Éó', 
              description: 'ÈÄü„ÅèÂãï„Åë„Çã„Çà„ÅÜ„Å´„Å™„ÇãÔºà15%UPÔºâ',
              apply: () => this.player.speed *= 1.15
            },
            { 
              id: 'maxHp', 
              name: '‚ù§Ô∏è ÊúÄÂ§ßHP„Ç¢„ÉÉ„Éó', 
              description: 'ÊúÄÂ§ßHP„Åå20Â¢ó„Åà„Å¶ÂÖ®ÂõûÂæ©',
              apply: () => {
                this.player.maxHp += 20;
                this.player.hp = this.player.maxHp;
              }
            },
            { 
              id: 'projectileCount', 
              name: 'üåü ÂºæÊï∞Â¢óÂä†', 
              description: 'ÊµÅ„ÇåÊòü„ÅÆÊï∞„Åå1„Å§Â¢ó„Åà„ÇãÔºà1Áô∫„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÅØ20%Ê∏õÔºâ',
              apply: () => {
                this.player.projectileCount += 1;
                this.player.damage *= 0.8; // 1Áô∫„ÅÇ„Åü„Çä„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí20%Ê∏õÂ∞ë
              }
            },
            { 
              id: 'piercing', 
              name: 'üí• Ë≤´ÈÄöÂäõ„Ç¢„ÉÉ„Éó', 
              description: 'ÊµÅ„ÇåÊòü„ÅåÊïµ„ÇíË≤´ÈÄö„Åô„ÇãÔºà+1Ôºâ',
              apply: () => this.player.piercing += 1
            },
          ];

          const selected = [];
          while (selected.length < 3) {
            const upgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
            if (!selected.includes(upgrade)) {
              selected.push(upgrade);
            }
          }

          this.upgradeOptions.innerHTML = '';
          selected.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card';
            card.innerHTML = `
              <h3>${upgrade.name}</h3>
              <p>${upgrade.description}</p>
            `;
            card.addEventListener('click', () => {
              upgrade.apply();
              this.updateUI();
              this.levelupModal.classList.add('hidden');
              this.isPaused = false;
              this.lastTime = performance.now();
              this.gameLoop(this.lastTime);
            });
            this.upgradeOptions.appendChild(card);
          });

          this.levelupModal.classList.remove('hidden');
        }

        updateUI() {
          this.hpFill.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
          this.hpText.textContent = `${Math.floor(this.player.hp)}/${this.player.maxHp}`;

          this.xpFill.style.width = `${(this.player.xp / this.player.xpToNextLevel) * 100}%`;
          this.xpText.textContent = `${Math.floor(this.player.xp)}/${this.player.xpToNextLevel}`;

          this.levelText.textContent = this.player.level;
        }

        updateBuffsUI() {
          const currentTime = performance.now();
          this.buffsContainer.innerHTML = '';
          
          const activeBuffs = [];
          
          if (this.activeEffects.speedBoost) {
            activeBuffs.push({
              name: '„Çπ„Éî„Éº„Éâ„Éñ„Éº„Çπ„Éà',
              emoji: '‚ö°',
              color: '#feca57',
              endTime: this.activeEffects.speedBoost,
              duration: 5000,
            });
          }
          
          if (this.activeEffects.powerUp) {
            activeBuffs.push({
              name: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó',
              emoji: 'üí™',
              color: '#ff6348',
              endTime: this.activeEffects.powerUp,
              duration: 8000,
            });
          }
          
          if (this.activeEffects.timeSlow) {
            activeBuffs.push({
              name: '„Çø„Ç§„É†„Çπ„É≠„Éº',
              emoji: 'üåÄ',
              color: '#5f27cd',
              endTime: this.activeEffects.timeSlow,
              duration: 5000,
            });
          }
          
          if (this.activeEffects.invincible) {
            activeBuffs.push({
              name: 'ÁÑ°Êïµ',
              emoji: '‚ú®',
              color: '#ff9ff3',
              endTime: this.activeEffects.invincible,
              duration: 3000,
            });
          }
          
          if (this.activeEffects.magnet) {
            activeBuffs.push({
              name: '„Éû„Ç∞„Éç„ÉÉ„Éà',
              emoji: 'üéØ',
              color: '#54a0ff',
              endTime: this.activeEffects.magnet,
              duration: 10000,
            });
          }
          
          if (this.player.shield && this.player.shield > 0) {
            activeBuffs.push({
              name: '„Ç∑„Éº„É´„Éâ',
              emoji: 'üõ°Ô∏è',
              color: '#48dbfb',
              endTime: null,
              duration: null,
            });
          }
          
          activeBuffs.forEach(buff => {
            const buffEl = document.createElement('div');
            buffEl.className = 'buff-item';
            buffEl.style.borderColor = buff.color;
            
            let timerHTML = '';
            if (buff.endTime) {
              const remaining = Math.max(0, buff.endTime - currentTime);
              const percent = (remaining / buff.duration) * 100;
              timerHTML = `
                <div class="buff-timer">
                  <div class="buff-timer-fill" style="width: ${percent}%; background: ${buff.color}"></div>
                </div>
              `;
            }
            
            buffEl.innerHTML = `
              <span class="buff-icon">${buff.emoji}</span>
              <div class="buff-info">
                <div class="buff-name">${buff.name}</div>
                ${timerHTML}
              </div>
            `;
            
            this.buffsContainer.appendChild(buffEl);
          });
        }

        gameOver() {
          this.isGameOver = true;
          this.stats.timeAlive = this.gameTime;
          this.stats.level = this.player.level;
          this.stopBGM();
          
          // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºBGM„ÇíÂÜçÁîü
          this.playBGM('gameover');

          const statsText = `
            ÁîüÂ≠òÊôÇÈñì: ${formatTime(this.stats.timeAlive)}<br>
            „É¨„Éô„É´: ${this.stats.level}<br>
            ÂÄí„Åó„ÅüÊïµ: ${this.stats.enemiesKilled}‰Ωì<br>
            ‰∏é„Åà„Åü„ÉÄ„É°„Éº„Ç∏: ${Math.floor(this.stats.damageDealt)}
          `;
          
          document.getElementById('final-stats').innerHTML = statsText;
          this.gameoverModal.classList.remove('hidden');
        }

        gameClear() {
          this.isGameOver = true;
          this.stats.timeAlive = this.gameTime;
          this.stats.level = this.player.level;
          this.stopBGM();
          
          // „ÇØ„É™„Ç¢BGM„ÇíÂÜçÁîü
          this.playBGM('clear');

          const statsText = `
            „ÇØ„É™„Ç¢ÊôÇÈñì: ${formatTime(this.stats.timeAlive)}<br>
            ÊúÄÁµÇ„É¨„Éô„É´: ${this.stats.level}<br>
            ÂÄí„Åó„ÅüÊïµ: ${this.stats.enemiesKilled}‰Ωì<br>
            ‰∏é„Åà„Åü„ÉÄ„É°„Éº„Ç∏: ${Math.floor(this.stats.damageDealt)}
          `;
          
          document.getElementById('clear-stats').innerHTML = statsText;
          this.gameclearModal.classList.remove('hidden');
        }

        render() {
          const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
          gradient.addColorStop(0, '#0f0c29');
          gradient.addColorStop(0.5, '#302b63');
          gradient.addColorStop(1, '#24243e');
          
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // ËªΩÈáèÁâà„Åß„ÅØÊòü„ÅÆÊï∞„ÇíÂâäÊ∏õÔºà„Çπ„Éû„Éõ„ÅØË∂ÖÂâäÊ∏õÔºâ
          this.ctx.fillStyle = '#ffffff';
          const starCount = this.isUltraLowSpec ? 10 : (this.isLowSpec ? 20 : 50);
          for (let i = 0; i < starCount; i++) {
            const x = (i * 137.5) % this.canvas.width;
            const y = (i * 213.7) % this.canvas.height;
            this.ctx.fillRect(x, y, 1, 1);
          }

          this.xpOrbs.forEach(orb => {
            this.ctx.save();
            
            const time = performance.now() / 300;
            const pulse = Math.sin(time) * 0.2 + 1;
            
            if (orb.isBossOrb) {
              // ‰∏≠„Éú„Çπ„Ç™„Éº„Éñ: „Ç≠„É©„Ç≠„É©„Ç®„Éï„Çß„ÇØ„Éà
              this.ctx.shadowColor = '#ffd700';
              this.ctx.shadowBlur = this.isLowSpec ? 10 : 25;
              
              const angle = time % (Math.PI * 2);
              const gradient = this.ctx.createRadialGradient(
                orb.position.x, orb.position.y, 0,
                orb.position.x, orb.position.y, orb.radius * pulse
              );
              
              const hue = (time * 50) % 360;
              gradient.addColorStop(0, `hsl(${hue}, 100%, 90%)`);
              gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 100%, 70%)`);
              gradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
              
              this.ctx.beginPath();
              this.ctx.arc(orb.position.x, orb.position.y, orb.radius * pulse, 0, Math.PI * 2);
              this.ctx.fillStyle = gradient;
              this.ctx.fill();
              
              this.ctx.strokeStyle = '#ffd700';
              this.ctx.lineWidth = 3;
              this.ctx.stroke();
              
              // „Ç≠„É©„Ç≠„É©Êòü(ËªΩÈáèÁâà„Åß„ÅØÁúÅÁï•)
              if (!this.isLowSpec) {
                for (let i = 0; i < 4; i++) {
                  const starAngle = angle + (i * Math.PI / 2);
                  const starDist = orb.radius * pulse + 5;
                  const starX = orb.position.x + Math.cos(starAngle) * starDist;
                  const starY = orb.position.y + Math.sin(starAngle) * starDist;
                  
                  this.ctx.fillStyle = '#ffffff';
                  this.ctx.beginPath();
                  this.ctx.arc(starX, starY, 3, 0, Math.PI * 2);
                  this.ctx.fill();
                }
              }
            } else {
              // ÈÄöÂ∏∏„Ç™„Éº„Éñ
              if (this.isLowSpec) {
                // ËªΩÈáèÁâà: „Ç∑„É≥„Éó„É´„Å™ÂÜÜ
                // „Çπ„Éû„Éõ„ÅØshadowBlur„Å™„Åó
                if (!this.isUltraLowSpec) {
                  this.ctx.shadowColor = '#00ffff';
                  this.ctx.shadowBlur = 8;
                }
                
                this.ctx.beginPath();
                this.ctx.arc(orb.position.x, orb.position.y, orb.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = '#00ffff';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
              } else {
                // ÈÄöÂ∏∏Áâà: ÂÖ≠ËßíÂΩ¢
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 15;
                
                const gradient = this.ctx.createRadialGradient(
                  orb.position.x, orb.position.y, 0,
                  orb.position.x, orb.position.y, orb.radius * pulse
                );
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.4, '#00ffff');
                gradient.addColorStop(1, '#00cccc');
                
                // ÂÖ≠ËßíÂΩ¢
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                  const angle = (Math.PI / 3) * i + time;
                  const x = orb.position.x + Math.cos(angle) * orb.radius * pulse;
                  const y = orb.position.y + Math.sin(angle) * orb.radius * pulse;
                  if (i === 0) this.ctx.moveTo(x, y);
                  else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // ‰∏≠ÂøÉ„Å´ÂÖâ„ÇãÁÇπ
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(orb.position.x, orb.position.y, 2, 0, Math.PI * 2);
                this.ctx.fill();
              }
            }
            
            this.ctx.restore();
          });

          this.items.forEach(item => {
            if (item.isAlive) {
              drawItem(this.ctx, item);
            }
          });

          this.enemies.forEach(enemy => {
            if (enemy.isAlive) {
              drawEnemy(this.ctx, enemy);
            }
          });

          this.enemyProjectiles.forEach(proj => {
            if (proj.isAlive) {
              this.ctx.save();
              
              if (this.isLowSpec) {
                // ËªΩÈáèÁâà: „Ç∑„É≥„Éó„É´„Å™Ëµ§„ÅÑÂÜÜ
                // „Çπ„Éû„Éõ„ÅØshadowBlur„Å™„Åó
                if (!this.isUltraLowSpec) {
                  this.ctx.shadowColor = '#ff0000';
                  this.ctx.shadowBlur = 10;
                }
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = '#ff3333';
                this.ctx.fill();
                this.ctx.strokeStyle = '#ffaaaa';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
              } else {
                // ÈÄöÂ∏∏Áâà: Ê¥æÊâã„Å™„Ç®„Éï„Çß„ÇØ„Éà
                // Â§ñÂÅ¥„ÅÆÂº∑„ÅÑÂÖâ
                this.ctx.shadowColor = '#ff0000';
                this.ctx.shadowBlur = 25;
                
                // ÂÖâ„ÅÆ„Ç™„Éº„É©ÔºàÂ§ñÂÅ¥Ôºâ
                const outerGradient = this.ctx.createRadialGradient(
                  proj.position.x, proj.position.y, 0,
                  proj.position.x, proj.position.y, proj.radius * 3
                );
                outerGradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                outerGradient.addColorStop(0.4, 'rgba(255, 50, 50, 0.4)');
                outerGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius * 3, 0, Math.PI * 2);
                this.ctx.fillStyle = outerGradient;
                this.ctx.fill();
                
                // Êú¨‰ΩìÔºàÊòé„Çã„ÅèÔºâ
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = '#ff3333';
                
                const bodyGradient = this.ctx.createRadialGradient(
                  proj.position.x, proj.position.y, 0,
                  proj.position.x, proj.position.y, proj.radius
                );
                bodyGradient.addColorStop(0, '#ffaaaa');
                bodyGradient.addColorStop(0.6, '#ff3333');
                bodyGradient.addColorStop(1, '#cc0000');
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = bodyGradient;
                this.ctx.fill();
                
                // ‰∏≠ÂøÉ„ÅÆÂº∑„ÅÑ„Éè„Ç§„É©„Ç§„Éà
                const highlightGradient = this.ctx.createRadialGradient(
                  proj.position.x - proj.radius * 0.3, 
                  proj.position.y - proj.radius * 0.3, 
                  0,
                  proj.position.x, 
                  proj.position.y, 
                  proj.radius * 0.6
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                this.ctx.beginPath();
                this.ctx.arc(proj.position.x, proj.position.y, proj.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = highlightGradient;
                this.ctx.fill();
                
                // ÂÖâ„ÇãÁ∏ÅÂèñ„Çä
                this.ctx.strokeStyle = '#ffaaaa';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
              }
              
              this.ctx.restore();
            }
          });

          this.projectiles.forEach(proj => {
            if (proj.isAlive) {
              this.ctx.save();
              this.ctx.translate(proj.position.x, proj.position.y);
              
              const spikes = 5;
              const outerRadius = proj.radius;
              const innerRadius = proj.radius / 2;

              this.ctx.beginPath();
              for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (Math.PI / spikes) * i;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) {
                  this.ctx.moveTo(x, y);
                } else {
                  this.ctx.lineTo(x, y);
                }
              }
              this.ctx.closePath();
              
              this.ctx.fillStyle = '#ffd700';
              this.ctx.fill();
              this.ctx.strokeStyle = '#ffed4e';
              this.ctx.lineWidth = 1;
              this.ctx.stroke();

              this.ctx.restore();
            }
          });

          drawPlayer(this.ctx, this.player, this.playerImage, performance.now(), this.isLowSpec, this.isUltraLowSpec);

          if (this.itemNotification) {
            const elapsed = performance.now() - this.itemNotificationTime;
            if (elapsed < 2000) {
              this.ctx.save();
              
              const alpha = elapsed < 1500 ? 1 : 1 - (elapsed - 1500) / 500;
              this.ctx.globalAlpha = alpha;
              
              const y = this.canvas.height / 2 - 100 - (elapsed / 10);
              
              this.ctx.font = 'bold 24px Arial';
              this.ctx.textAlign = 'center';
              this.ctx.textBaseline = 'middle';
              
              this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
              this.ctx.fillRect(this.canvas.width / 2 - 120, y - 20, 240, 50);
              
              this.ctx.fillStyle = this.itemNotification.color;
              this.ctx.fillText(`${this.itemNotification.emoji} ${this.itemNotification.name}`, this.canvas.width / 2, y);
              
              this.ctx.restore();
            } else {
              this.itemNotification = null;
            }
          }
        }
      }

      const canvas = document.getElementById('game-canvas');
      new Game(canvas);

      console.log('üåü „Ç≥„Çπ„É¢„Å™„ÅΩ„Çä„Åü„Çì „Çµ„Éê„Ç§„Éê„Éº„Çπ„Çø„Éº„Ç∫ üçù');
      console.log('WASD„Åæ„Åü„ÅØÊñπÂêë„Ç≠„Éº„ÅßÁßªÂãï„Åó„Å¶„Å≠ÔºÅ');
    })();
  </script>
</body>
</html>
